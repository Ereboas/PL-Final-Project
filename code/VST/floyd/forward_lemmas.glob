DIGEST e69827ad4e9541b2ddb12404eb498ddb
FVST.floyd.forward_lemmas
R15:29 VST.floyd.base2 <> <> lib
R47:69 VST.floyd.client_lemmas <> <> lib
R87:109 VST.floyd.closed_lemmas <> <> lib
prf 176:191 <> semax_while_peel
R208:216 VST.veric.mpred <> compspecs class
binder 204:205 <> CS:1
R227:236 VST.veric.juicy_extspec <> OracleKind class
binder 220:224 <> Espec:2
binder 239:241 <> Inv:3
binder 243:247 <> Delta:4
binder 249:249 <> P:5
binder 251:254 <> expr:6
binder 256:259 <> body:7
binder 261:261 <> R:8
R393:398 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R445:450 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R452:456 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R494:494 VST.floyd.forward_lemmas <> R:8 var
R476:481 compcert.cfrontend.Clight <> Swhile def
R488:491 VST.floyd.forward_lemmas <> body:7 var
R483:486 VST.floyd.forward_lemmas <> expr:6 var
R473:473 VST.floyd.forward_lemmas <> P:5 var
R467:471 VST.floyd.forward_lemmas <> Delta:4 var
R461:465 VST.floyd.forward_lemmas <> Espec:2 var
R458:459 VST.floyd.forward_lemmas <> CS:1 var
R400:404 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R444:444 VST.floyd.forward_lemmas <> R:8 var
R426:431 compcert.cfrontend.Clight <> Swhile def
R438:441 VST.floyd.forward_lemmas <> body:7 var
R433:436 VST.floyd.forward_lemmas <> expr:6 var
R421:423 VST.floyd.forward_lemmas <> Inv:3 var
R415:419 VST.floyd.forward_lemmas <> Delta:4 var
R409:413 VST.floyd.forward_lemmas <> Espec:2 var
R406:407 VST.floyd.forward_lemmas <> CS:1 var
R267:271 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R370:385 VST.veric.SeparationLogic <> loop1_ret_assert def
R391:391 VST.floyd.forward_lemmas <> R:8 var
R387:389 VST.floyd.forward_lemmas <> Inv:3 var
R291:299 compcert.cfrontend.Clight <> Ssequence constr
R333:336 VST.floyd.forward_lemmas <> body:7 var
R302:312 compcert.cfrontend.Clight <> Sifthenelse constr
R325:330 compcert.cfrontend.Clight <> Sbreak constr
R319:323 compcert.cfrontend.Clight <> Sskip constr
R314:317 VST.floyd.forward_lemmas <> expr:6 var
R288:288 VST.floyd.forward_lemmas <> P:5 var
R282:286 VST.floyd.forward_lemmas <> Delta:4 var
R276:280 VST.floyd.forward_lemmas <> Espec:2 var
R273:274 VST.floyd.forward_lemmas <> CS:1 var
R518:535 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic semax_loop_unroll1 prfax
R518:535 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic semax_loop_unroll1 prfax
R579:587 VST.floyd.canon <> semax_pre thm
R601:610 VST.floyd.canon <> sequential thm
R619:628 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_skip prfax
R579:587 VST.floyd.canon <> semax_pre thm
R601:610 VST.floyd.canon <> sequential thm
R619:628 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_skip prfax
R650:660 VST.floyd.assert_lemmas <> ENTAIL_refl thm
R650:660 VST.floyd.assert_lemmas <> ENTAIL_refl thm
prf 675:695 <> typelist2list_arglist
binder 705:705 <> l:9
binder 707:707 <> i:10
R731:733 Coq.Init.Logic <> ::type_scope:x_'='_x not
R710:712 Coq.Lists.List <> map def
R719:725 VST.veric.SeparationLogic <> arglist def
R729:729 VST.floyd.forward_lemmas <> l:9 var
R727:727 VST.floyd.forward_lemmas <> i:10 var
R714:716 Coq.Init.Datatypes <> snd def
R734:746 VST.veric.mpred <> typelist2list def
R748:748 VST.floyd.forward_lemmas <> l:9 var
prf 843:869 <> semax_func_cons_ext_vacuous
R892:901 VST.veric.juicy_extspec <> OracleKind class
binder 885:889 <> Espec:11
R909:916 VST.veric.mpred <> varspecs def
binder 905:905 <> V:12
R924:931 VST.veric.mpred <> funspecs def
binder 920:920 <> G:13
R939:947 VST.veric.mpred <> compspecs class
binder 935:935 <> C:14
binder 950:951 <> ge:15
R968:971 Coq.Init.Datatypes <> list ind
R979:981 Coq.Init.Datatypes <> ::type_scope:x_'*'_x not
R974:978 compcert.common.AST <> ident def
R982:994 compcert.cfrontend.Clight <> fundef def
binder 963:964 <> fs:16
R1004:1008 compcert.common.AST <> ident def
binder 999:1000 <> id:17
R1017:1033 compcert.common.AST <> external_function ind
binder 1012:1013 <> ef:18
R1055:1062 compcert.cfrontend.Ctypes <> typelist ind
binder 1046:1051 <> argsig:19
R1075:1078 compcert.cfrontend.Ctypes <> type ind
binder 1066:1071 <> retsig:20
R1096:1103 VST.veric.mpred <> funspecs def
binder 1091:1092 <> G':21
binder 1106:1107 <> cc:22
binder 1109:1109 <> b:23
R1155:1165 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R1346:1364 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R1396:1414 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R1477:1487 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R1511:1521 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R1522:1531 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax_func defax
R1645:1648 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R1593:1593 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R1596:1597 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R1644:1644 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R1594:1595 VST.floyd.forward_lemmas <> id:17 var
R1598:1612 VST.floyd.base2 <> vacuous_funspec def
R1615:1622 compcert.cfrontend.Ctypes <> External constr
R1641:1642 VST.floyd.forward_lemmas <> cc:22 var
R1634:1639 VST.floyd.forward_lemmas <> retsig:20 var
R1627:1632 VST.floyd.forward_lemmas <> argsig:19 var
R1624:1625 VST.floyd.forward_lemmas <> ef:18 var
R1649:1650 VST.floyd.forward_lemmas <> G':21 var
R1575:1578 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R1541:1541 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R1544:1545 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R1574:1574 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R1542:1543 VST.floyd.forward_lemmas <> id:17 var
R1546:1553 compcert.cfrontend.Ctypes <> External constr
R1572:1573 VST.floyd.forward_lemmas <> cc:22 var
R1565:1570 VST.floyd.forward_lemmas <> retsig:20 var
R1558:1563 VST.floyd.forward_lemmas <> argsig:19 var
R1555:1556 VST.floyd.forward_lemmas <> ef:18 var
R1579:1580 VST.floyd.forward_lemmas <> fs:16 var
R1537:1538 VST.floyd.forward_lemmas <> ge:15 var
R1535:1535 VST.floyd.forward_lemmas <> G:13 var
R1533:1533 VST.floyd.forward_lemmas <> V:12 var
R1488:1497 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax_func defax
R1509:1510 VST.floyd.forward_lemmas <> G':21 var
R1506:1507 VST.floyd.forward_lemmas <> fs:16 var
R1503:1504 VST.floyd.forward_lemmas <> ge:15 var
R1501:1501 VST.floyd.forward_lemmas <> G:13 var
R1499:1499 VST.floyd.forward_lemmas <> V:12 var
R1439:1441 Coq.Init.Logic <> ::type_scope:x_'='_x not
R1415:1433 compcert.common.Globalenvs Genv find_funct_ptr def
R1438:1438 VST.floyd.forward_lemmas <> b:23 var
R1435:1436 VST.floyd.forward_lemmas <> ge:15 var
R1442:1445 Coq.Init.Datatypes <> Some constr
R1448:1455 compcert.cfrontend.Ctypes <> External constr
R1474:1475 VST.floyd.forward_lemmas <> cc:22 var
R1467:1472 VST.floyd.forward_lemmas <> retsig:20 var
R1460:1465 VST.floyd.forward_lemmas <> argsig:19 var
R1457:1458 VST.floyd.forward_lemmas <> ef:18 var
R1387:1389 Coq.Init.Logic <> ::type_scope:x_'='_x not
R1365:1380 compcert.common.Globalenvs Genv find_symbol def
R1385:1386 VST.floyd.forward_lemmas <> id:17 var
R1382:1383 VST.floyd.forward_lemmas <> ge:15 var
R1390:1393 Coq.Init.Datatypes <> Some constr
R1395:1395 VST.floyd.forward_lemmas <> b:23 var
R1175:1196 Coq.Init.Logic <> ::type_scope:x_'='_x not
R1343:1345 Coq.Init.Logic <> ::type_scope:x_'='_x not
R1166:1171 compcert.common.AST <> ef_sig def
R1173:1174 VST.floyd.forward_lemmas <> ef:18 var
R1197:1204 compcert.common.AST <> sig_args proj
R1197:1204 compcert.common.AST <> sig_args proj
R1246:1252 compcert.common.AST <> sig_res proj
R1290:1295 compcert.common.AST <> sig_cc proj
R1300:1311 VST.floyd.base2 <> cc_of_fundef def
R1314:1321 compcert.cfrontend.Ctypes <> External constr
R1340:1341 VST.floyd.forward_lemmas <> cc:22 var
R1333:1338 VST.floyd.forward_lemmas <> retsig:20 var
R1326:1331 VST.floyd.forward_lemmas <> argsig:19 var
R1323:1324 VST.floyd.forward_lemmas <> ef:18 var
R1257:1271 compcert.cfrontend.Ctypes <> rettype_of_type def
R1273:1278 VST.floyd.forward_lemmas <> retsig:20 var
R1209:1227 compcert.cfrontend.Ctypes <> typlist_of_typelist def
R1229:1234 VST.floyd.forward_lemmas <> argsig:19 var
R1119:1119 Coq.Init.Logic <> ::type_scope:x_'='_x not
R1146:1149 Coq.Init.Logic <> ::type_scope:x_'='_x not
R1120:1129 VST.veric.base <> id_in_list def
R1135:1137 Coq.Lists.List <> map def
R1143:1144 VST.floyd.forward_lemmas <> fs:16 var
R1139:1141 Coq.Init.Datatypes <> fst def
R1131:1132 VST.floyd.forward_lemmas <> id:17 var
R1150:1154 Coq.Init.Datatypes <> false constr
R1682:1700 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_func_cons_ext prfax
R1799:1800 VST.msl.seplog <> FF meth
R1783:1784 VST.msl.seplog <> FF meth
R1743:1757 VST.veric.rmaps <> ConstType constr
R1759:1768 VST.floyd.base2 <> Impossible ind
R1682:1700 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_func_cons_ext prfax
R1799:1800 VST.msl.seplog <> FF meth
R1783:1784 VST.msl.seplog <> FF meth
R1743:1757 VST.veric.rmaps <> ConstType constr
R1759:1768 VST.floyd.base2 <> Impossible ind
R1884:1904 VST.floyd.forward_lemmas <> typelist2list_arglist thm
R1884:1904 VST.floyd.forward_lemmas <> typelist2list_arglist thm
R1884:1904 VST.floyd.forward_lemmas <> typelist2list_arglist thm
R1996:2005 VST.msl.seplog <> andp_left1 meth
R2008:2014 VST.msl.log_normalize <> FF_left thm
R1996:2005 VST.msl.seplog <> andp_left1 meth
R2008:2014 VST.msl.log_normalize <> FF_left thm
R2054:2070 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_external_FF prfax
R2054:2070 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_external_FF prfax
prf 2085:2111 <> semax_func_cons_int_vacuous
R2124:2133 VST.veric.juicy_extspec <> OracleKind class
binder 2116:2120 <> Espec:24
R2141:2148 VST.veric.mpred <> varspecs def
binder 2137:2137 <> V:25
R2156:2163 VST.veric.mpred <> funspecs def
binder 2152:2152 <> G:26
R2177:2185 VST.veric.mpred <> compspecs class
binder 2172:2173 <> cs:27
R2194:2199 compcert.common.Globalenvs Genv t rec
R2219:2222 compcert.cfrontend.Ctypes <> type ind
R2202:2207 compcert.cfrontend.Ctypes <> fundef ind
R2209:2216 compcert.cfrontend.Clight <> function rec
binder 2189:2190 <> ge:28
R2235:2238 Coq.Init.Datatypes <> list ind
R2246:2248 Coq.Init.Datatypes <> ::type_scope:x_'*'_x not
R2241:2245 compcert.common.AST <> ident def
R2249:2261 compcert.cfrontend.Clight <> fundef def
binder 2230:2231 <> fs:29
R2271:2275 compcert.common.AST <> ident def
binder 2266:2267 <> id:30
binder 2278:2282 <> ifunc:31
R2293:2297 compcert.common.Values <> block def
binder 2289:2289 <> b:32
binder 2300:2301 <> G':33
R2336:2338 Coq.Init.Logic <> ::type_scope:x_'='_x not
R2310:2319 VST.veric.base <> id_in_list def
R2325:2327 Coq.Lists.List <> map def
R2333:2334 VST.floyd.forward_lemmas <> fs:29 var
R2329:2331 Coq.Init.Datatypes <> fst def
R2321:2322 VST.floyd.forward_lemmas <> id:30 var
R2339:2343 Coq.Init.Datatypes <> false constr
binder 2306:2307 <> ID:34
R2379:2381 Coq.Init.Logic <> ::type_scope:x_'='_x not
R2354:2363 VST.veric.base <> id_in_list def
R2369:2371 Coq.Lists.List <> map def
R2377:2377 VST.floyd.forward_lemmas <> G:26 var
R2373:2375 Coq.Init.Datatypes <> fst def
R2365:2366 VST.floyd.forward_lemmas <> id:30 var
R2382:2385 Coq.Init.Datatypes <> true constr
binder 2349:2351 <> ID2:35
R2419:2421 Coq.Init.Logic <> ::type_scope:x_'='_x not
R2397:2412 compcert.common.Globalenvs Genv find_symbol def
R2417:2418 VST.floyd.forward_lemmas <> id:30 var
R2414:2415 VST.floyd.forward_lemmas <> ge:28 var
R2422:2425 Coq.Init.Datatypes <> Some constr
R2427:2427 VST.floyd.forward_lemmas <> b:32 var
binder 2391:2394 <> GfsB:36
R2464:2466 Coq.Init.Logic <> ::type_scope:x_'='_x not
R2440:2458 compcert.common.Globalenvs Genv find_funct_ptr def
R2463:2463 VST.floyd.forward_lemmas <> b:32 var
R2460:2461 VST.floyd.forward_lemmas <> ge:28 var
R2467:2470 Coq.Init.Datatypes <> Some constr
R2473:2480 compcert.cfrontend.Ctypes <> Internal constr
R2482:2486 VST.floyd.forward_lemmas <> ifunc:31 var
binder 2433:2437 <> GffpB:37
R2501:2506 Coq.Lists.List <> Forall ind
R2574:2580 compcert.cfrontend.Clight <> fn_vars proj
R2582:2586 VST.floyd.forward_lemmas <> ifunc:31 var
R2523:2525 Coq.Init.Datatypes <> ::type_scope:x_'*'_x not
R2518:2522 compcert.common.AST <> ident def
R2526:2529 compcert.cfrontend.Ctypes <> type ind
binder 2513:2514 <> it:38
R2564:2566 Coq.Init.Logic <> ::type_scope:x_'='_x not
R2534:2546 compcert.cfrontend.Ctypes <> complete_type def
R2557:2559 Coq.Init.Datatypes <> snd def
R2561:2562 VST.floyd.forward_lemmas <> it:38 var
R2548:2554 VST.veric.mpred <> cenv_cs meth
R2567:2570 Coq.Init.Datatypes <> true constr
binder 2493:2498 <> CTvars:39
R2601:2612 compcert.lib.Coqlib <> list_norepet ind
R2640:2643 Coq.Init.Datatypes <> ::list_scope:x_'++'_x not
R2615:2617 Coq.Lists.List <> map def
R2624:2632 compcert.cfrontend.Clight <> fn_params proj
R2634:2638 VST.floyd.forward_lemmas <> ifunc:31 var
R2619:2621 Coq.Init.Datatypes <> fst def
R2644:2646 Coq.Lists.List <> map def
R2653:2660 compcert.cfrontend.Clight <> fn_temps proj
R2662:2666 VST.floyd.forward_lemmas <> ifunc:31 var
R2648:2650 Coq.Init.Datatypes <> fst def
binder 2593:2598 <> LNR_PT:40
R2684:2695 compcert.lib.Coqlib <> list_norepet ind
R2698:2700 Coq.Lists.List <> map def
R2707:2713 compcert.cfrontend.Clight <> fn_vars proj
R2715:2719 VST.floyd.forward_lemmas <> ifunc:31 var
R2702:2704 Coq.Init.Datatypes <> fst def
binder 2674:2681 <> LNR_Vars:41
R2737:2754 VST.veric.semax <> var_sizes_ok def
R2765:2771 compcert.cfrontend.Clight <> fn_vars proj
R2773:2777 VST.floyd.forward_lemmas <> ifunc:31 var
R2756:2762 VST.veric.mpred <> cenv_cs meth
binder 2727:2734 <> VarSizes:42
R2792:2801 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax_func defax
R2822:2823 VST.floyd.forward_lemmas <> G':33 var
R2819:2820 VST.floyd.forward_lemmas <> fs:29 var
R2816:2817 VST.floyd.forward_lemmas <> ge:28 var
R2813:2814 VST.floyd.forward_lemmas <> cs:27 var
R2811:2811 VST.floyd.forward_lemmas <> G:26 var
R2809:2809 VST.floyd.forward_lemmas <> V:25 var
R2803:2807 VST.floyd.forward_lemmas <> Espec:24 var
binder 2784:2788 <> Sfunc:43
R2830:2839 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax_func defax
R2929:2932 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R2891:2891 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R2894:2895 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R2928:2928 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R2892:2893 VST.floyd.forward_lemmas <> id:30 var
R2896:2910 VST.floyd.base2 <> vacuous_funspec def
R2913:2920 compcert.cfrontend.Ctypes <> Internal constr
R2922:2926 VST.floyd.forward_lemmas <> ifunc:31 var
R2933:2934 VST.floyd.forward_lemmas <> G':33 var
R2878:2881 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R2858:2858 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R2861:2862 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R2877:2877 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R2859:2860 VST.floyd.forward_lemmas <> id:30 var
R2863:2870 compcert.cfrontend.Ctypes <> Internal constr
R2872:2876 VST.floyd.forward_lemmas <> ifunc:31 var
R2882:2883 VST.floyd.forward_lemmas <> fs:29 var
R2854:2855 VST.floyd.forward_lemmas <> ge:28 var
R2851:2852 VST.floyd.forward_lemmas <> cs:27 var
R2849:2849 VST.floyd.forward_lemmas <> G:26 var
R2847:2847 VST.floyd.forward_lemmas <> V:25 var
R2841:2845 VST.floyd.forward_lemmas <> Espec:24 var
R2952:2966 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_func_cons prfax
R2952:2966 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_func_cons prfax
R3019:3038 VST.veric.SeparationLogic <> semax_body_params_ok def
R3049:3070 VST.veric.base <> compute_list_norepet_i thm
R3049:3070 VST.veric.base <> compute_list_norepet_i thm
R3107:3128 VST.veric.base <> compute_list_norepet_i thm
R3107:3128 VST.veric.base <> compute_list_norepet_i thm
prf 3343:3380 <> semax_prog_semax_func_cons_int_vacuous
R3393:3402 VST.veric.juicy_extspec <> OracleKind class
binder 3385:3389 <> Espec:44
R3410:3417 VST.veric.mpred <> varspecs def
binder 3406:3406 <> V:45
R3425:3432 VST.veric.mpred <> funspecs def
binder 3421:3421 <> G:46
R3446:3454 VST.veric.mpred <> compspecs class
binder 3441:3442 <> cs:47
R3463:3468 compcert.common.Globalenvs Genv t rec
R3488:3491 compcert.cfrontend.Ctypes <> type ind
R3471:3476 compcert.cfrontend.Ctypes <> fundef ind
R3478:3485 compcert.cfrontend.Clight <> function rec
binder 3458:3459 <> ge:48
R3504:3507 Coq.Init.Datatypes <> list ind
R3515:3517 Coq.Init.Datatypes <> ::type_scope:x_'*'_x not
R3510:3514 compcert.common.AST <> ident def
R3518:3530 compcert.cfrontend.Clight <> fundef def
binder 3499:3500 <> fs:49
R3540:3544 compcert.common.AST <> ident def
binder 3535:3536 <> id:50
binder 3547:3551 <> ifunc:51
R3562:3566 compcert.common.Values <> block def
binder 3558:3558 <> b:52
binder 3569:3570 <> G':53
R3605:3607 Coq.Init.Logic <> ::type_scope:x_'='_x not
R3579:3588 VST.veric.base <> id_in_list def
R3594:3596 Coq.Lists.List <> map def
R3602:3603 VST.floyd.forward_lemmas <> fs:49 var
R3598:3600 Coq.Init.Datatypes <> fst def
R3590:3591 VST.floyd.forward_lemmas <> id:50 var
R3608:3612 Coq.Init.Datatypes <> false constr
binder 3575:3576 <> ID:54
R3692:3694 Coq.Init.Logic <> ::type_scope:x_'='_x not
R3670:3685 compcert.common.Globalenvs Genv find_symbol def
R3690:3691 VST.floyd.forward_lemmas <> id:50 var
R3687:3688 VST.floyd.forward_lemmas <> ge:48 var
R3695:3698 Coq.Init.Datatypes <> Some constr
R3700:3700 VST.floyd.forward_lemmas <> b:52 var
binder 3664:3667 <> GfsB:55
R3737:3739 Coq.Init.Logic <> ::type_scope:x_'='_x not
R3713:3731 compcert.common.Globalenvs Genv find_funct_ptr def
R3736:3736 VST.floyd.forward_lemmas <> b:52 var
R3733:3734 VST.floyd.forward_lemmas <> ge:48 var
R3740:3743 Coq.Init.Datatypes <> Some constr
R3746:3753 compcert.cfrontend.Ctypes <> Internal constr
R3755:3759 VST.floyd.forward_lemmas <> ifunc:51 var
binder 3706:3710 <> GffpB:56
R3774:3779 Coq.Lists.List <> Forall ind
R3847:3853 compcert.cfrontend.Clight <> fn_vars proj
R3855:3859 VST.floyd.forward_lemmas <> ifunc:51 var
R3796:3798 Coq.Init.Datatypes <> ::type_scope:x_'*'_x not
R3791:3795 compcert.common.AST <> ident def
R3799:3802 compcert.cfrontend.Ctypes <> type ind
binder 3786:3787 <> it:57
R3837:3839 Coq.Init.Logic <> ::type_scope:x_'='_x not
R3807:3819 compcert.cfrontend.Ctypes <> complete_type def
R3830:3832 Coq.Init.Datatypes <> snd def
R3834:3835 VST.floyd.forward_lemmas <> it:57 var
R3821:3827 VST.veric.mpred <> cenv_cs meth
R3840:3843 Coq.Init.Datatypes <> true constr
binder 3766:3771 <> CTvars:58
R3874:3885 compcert.lib.Coqlib <> list_norepet ind
R3913:3916 Coq.Init.Datatypes <> ::list_scope:x_'++'_x not
R3888:3890 Coq.Lists.List <> map def
R3897:3905 compcert.cfrontend.Clight <> fn_params proj
R3907:3911 VST.floyd.forward_lemmas <> ifunc:51 var
R3892:3894 Coq.Init.Datatypes <> fst def
R3917:3919 Coq.Lists.List <> map def
R3926:3933 compcert.cfrontend.Clight <> fn_temps proj
R3935:3939 VST.floyd.forward_lemmas <> ifunc:51 var
R3921:3923 Coq.Init.Datatypes <> fst def
binder 3866:3871 <> LNR_PT:59
R3957:3968 compcert.lib.Coqlib <> list_norepet ind
R3971:3973 Coq.Lists.List <> map def
R3980:3986 compcert.cfrontend.Clight <> fn_vars proj
R3988:3992 VST.floyd.forward_lemmas <> ifunc:51 var
R3975:3977 Coq.Init.Datatypes <> fst def
binder 3947:3954 <> LNR_Vars:60
R4010:4027 VST.veric.semax <> var_sizes_ok def
R4038:4044 compcert.cfrontend.Clight <> fn_vars proj
R4046:4050 VST.floyd.forward_lemmas <> ifunc:51 var
R4029:4035 VST.veric.mpred <> cenv_cs meth
binder 4000:4007 <> VarSizes:61
R4065:4085 VST.veric.semax_prog <> semax_func def
R4106:4107 VST.floyd.forward_lemmas <> G':53 var
R4103:4104 VST.floyd.forward_lemmas <> fs:49 var
R4100:4101 VST.floyd.forward_lemmas <> ge:48 var
R4097:4098 VST.floyd.forward_lemmas <> cs:47 var
R4095:4095 VST.floyd.forward_lemmas <> G:46 var
R4093:4093 VST.floyd.forward_lemmas <> V:45 var
R4087:4091 VST.floyd.forward_lemmas <> Espec:44 var
binder 4057:4061 <> Sfunc:62
R4114:4134 VST.veric.semax_prog <> semax_func def
R4224:4227 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R4186:4186 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R4189:4190 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R4223:4223 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R4187:4188 VST.floyd.forward_lemmas <> id:50 var
R4191:4205 VST.floyd.base2 <> vacuous_funspec def
R4208:4215 compcert.cfrontend.Ctypes <> Internal constr
R4217:4221 VST.floyd.forward_lemmas <> ifunc:51 var
R4228:4229 VST.floyd.forward_lemmas <> G':53 var
R4173:4176 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R4153:4153 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R4156:4157 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R4172:4172 Coq.Init.Datatypes <> ::core_scope:'('_x_','_x_','_'..'_','_x_')' not
R4154:4155 VST.floyd.forward_lemmas <> id:50 var
R4158:4165 compcert.cfrontend.Ctypes <> Internal constr
R4167:4171 VST.floyd.forward_lemmas <> ifunc:51 var
R4177:4178 VST.floyd.forward_lemmas <> fs:49 var
R4149:4150 VST.floyd.forward_lemmas <> ge:48 var
R4146:4147 VST.floyd.forward_lemmas <> cs:47 var
R4144:4144 VST.floyd.forward_lemmas <> G:46 var
R4142:4142 VST.floyd.forward_lemmas <> V:45 var
R4136:4140 VST.floyd.forward_lemmas <> Espec:44 var
R4246:4261 VST.veric.base <> id_in_list_false thm
R4246:4261 VST.veric.base <> id_in_list_false thm
R4385:4400 compcert.cfrontend.Clight <> type_of_function def
R4418:4421 VST.veric.mpred <> TTL1 thm
R4418:4421 VST.veric.mpred <> TTL1 thm
R4418:4421 VST.veric.mpred <> TTL1 thm
R4682:4693 compcert.lib.Maps PTree gsspec thm
R4682:4693 compcert.lib.Maps PTree gsspec thm
R4682:4693 compcert.lib.Maps PTree gsspec thm
R4711:4713 compcert.lib.Coqlib <> peq def
R4711:4713 compcert.lib.Coqlib <> peq def
R4835:4837 Coq.Init.Logic <> ::type_scope:x_'='_x not
R4835:4837 Coq.Init.Logic <> ::type_scope:x_'='_x not
R4896:4905 VST.veric.tycontext <> sub_option def
R4908:4920 compcert.cfrontend.Clight <> fundef def
R5092:5104 compcert.cfrontend.Clight <> fundef def
prf 5393:5406 <> int_eq_false_e
binder 5418:5418 <> i:63
binder 5420:5420 <> j:64
R5441:5444 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R5446:5449 Coq.Init.Logic <> ::type_scope:x_'<>'_x not
R5445:5445 VST.floyd.forward_lemmas <> i:63 var
R5450:5450 VST.floyd.forward_lemmas <> j:64 var
R5433:5435 Coq.Init.Logic <> ::type_scope:x_'='_x not
R5423:5428 compcert.lib.Integers Int eq def
R5432:5432 VST.floyd.forward_lemmas <> j:64 var
R5430:5430 VST.floyd.forward_lemmas <> i:63 var
R5436:5440 Coq.Init.Datatypes <> false constr
R5490:5500 compcert.lib.Integers Int eq_true thm
R5490:5500 compcert.lib.Integers Int eq_true thm
R5490:5500 compcert.lib.Integers Int eq_true thm
prf 5528:5548 <> semax_ifthenelse_PQR'
binder 5562:5566 <> Espec:65
R5573:5581 VST.veric.mpred <> compspecs class
binder 5569:5570 <> cs:66
R5588:5590 compcert.common.Values <> val ind
binder 5585:5585 <> v:67
binder 5593:5597 <> Delta:68
binder 5599:5599 <> P:69
binder 5601:5601 <> Q:70
binder 5603:5603 <> R:71
R5609:5612 compcert.cfrontend.Clight <> expr ind
binder 5606:5606 <> b:72
binder 5615:5615 <> c:73
binder 5617:5617 <> d:74
binder 5619:5622 <> Post:75
R5658:5666 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R5765:5774 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R5858:5866 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R5978:5986 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R6099:6107 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R6109:6113 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R6205:6208 VST.floyd.forward_lemmas <> Post:75 var
R6186:6196 compcert.cfrontend.Clight <> Sifthenelse constr
R6202:6202 VST.floyd.forward_lemmas <> d:74 var
R6200:6200 VST.floyd.forward_lemmas <> c:73 var
R6198:6198 VST.floyd.forward_lemmas <> b:72 var
R6131:6135 VST.floyd.canon <> PROPx def
R6140:6145 VST.floyd.canon <> LOCALx def
R6150:6153 VST.floyd.canon <> SEPx def
R6155:6155 VST.floyd.forward_lemmas <> R:71 var
R6147:6147 VST.floyd.forward_lemmas <> Q:70 var
R6137:6137 VST.floyd.forward_lemmas <> P:69 var
R6124:6128 VST.floyd.forward_lemmas <> Delta:68 var
R6118:6122 VST.floyd.forward_lemmas <> Espec:65 var
R6115:6116 VST.floyd.forward_lemmas <> cs:66 var
R5988:5992 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R6095:6098 VST.floyd.forward_lemmas <> Post:75 var
R6093:6093 VST.floyd.forward_lemmas <> d:74 var
R6010:6014 VST.floyd.canon <> PROPx def
R6049:6054 VST.floyd.canon <> LOCALx def
R6059:6062 VST.floyd.canon <> SEPx def
R6064:6064 VST.floyd.forward_lemmas <> R:71 var
R6056:6056 VST.floyd.forward_lemmas <> Q:70 var
R6041:6044 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R6017:6027 VST.veric.SeparationLogic <> typed_false def
R6040:6040 VST.floyd.forward_lemmas <> v:67 var
R6030:6035 compcert.cfrontend.Clight <> typeof def
R6037:6037 VST.floyd.forward_lemmas <> b:72 var
R6045:6045 VST.floyd.forward_lemmas <> P:69 var
R6003:6007 VST.floyd.forward_lemmas <> Delta:68 var
R5997:6001 VST.floyd.forward_lemmas <> Espec:65 var
R5994:5995 VST.floyd.forward_lemmas <> cs:66 var
R5868:5872 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R5974:5977 VST.floyd.forward_lemmas <> Post:75 var
R5972:5972 VST.floyd.forward_lemmas <> c:73 var
R5890:5894 VST.floyd.canon <> PROPx def
R5928:5933 VST.floyd.canon <> LOCALx def
R5938:5941 VST.floyd.canon <> SEPx def
R5943:5943 VST.floyd.forward_lemmas <> R:71 var
R5935:5935 VST.floyd.forward_lemmas <> Q:70 var
R5920:5923 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R5897:5906 VST.veric.SeparationLogic <> typed_true def
R5919:5919 VST.floyd.forward_lemmas <> v:67 var
R5909:5914 compcert.cfrontend.Clight <> typeof def
R5916:5916 VST.floyd.forward_lemmas <> b:72 var
R5924:5924 VST.floyd.forward_lemmas <> P:69 var
R5883:5887 VST.floyd.forward_lemmas <> Delta:68 var
R5877:5881 VST.floyd.forward_lemmas <> Espec:65 var
R5874:5875 VST.floyd.forward_lemmas <> cs:66 var
R5775:5781 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R5787:5788 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R5816:5828 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R5782:5786 VST.floyd.forward_lemmas <> Delta:68 var
R5789:5793 VST.floyd.canon <> PROPx def
R5798:5803 VST.floyd.canon <> LOCALx def
R5808:5811 VST.floyd.canon <> SEPx def
R5813:5813 VST.floyd.forward_lemmas <> R:71 var
R5805:5805 VST.floyd.forward_lemmas <> Q:70 var
R5795:5795 VST.floyd.forward_lemmas <> P:69 var
R5829:5833 VST.veric.SeparationLogic <> local def
R5836:5837 VST.veric.lift LiftNotation :::'`('_x_')' not
R5842:5856 VST.veric.lift LiftNotation :::'`('_x_')' not
R5838:5839 Coq.Init.Logic <> eq ind
R5841:5841 VST.floyd.forward_lemmas <> v:67 var
R5845:5853 VST.veric.expr <> eval_expr def
R5855:5855 VST.floyd.forward_lemmas <> b:72 var
R5667:5673 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R5679:5680 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R5708:5722 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R5764:5764 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R5674:5678 VST.floyd.forward_lemmas <> Delta:68 var
R5681:5685 VST.floyd.canon <> PROPx def
R5690:5695 VST.floyd.canon <> LOCALx def
R5700:5703 VST.floyd.canon <> SEPx def
R5705:5705 VST.floyd.forward_lemmas <> R:71 var
R5697:5697 VST.floyd.forward_lemmas <> Q:70 var
R5687:5687 VST.floyd.forward_lemmas <> P:69 var
R5723:5729 VST.veric.SeparationLogic <> tc_expr def
R5738:5742 compcert.cfrontend.Clight <> Eunop constr
R5759:5762 compcert.exportclight.Clightdefs <> tint def
R5757:5757 VST.floyd.forward_lemmas <> b:72 var
R5744:5755 compcert.cfrontend.Cop <> Onotbool constr
R5731:5735 VST.floyd.forward_lemmas <> Delta:68 var
R5651:5653 Coq.Init.Logic <> ::type_scope:x_'='_x not
R5631:5639 VST.veric.expr <> bool_type def
R5642:5647 compcert.cfrontend.Clight <> typeof def
R5649:5649 VST.floyd.forward_lemmas <> b:72 var
R5654:5657 Coq.Init.Datatypes <> true constr
R6235:6243 VST.floyd.canon <> semax_pre thm
R6257:6272 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_ifthenelse prfax
R6235:6243 VST.floyd.canon <> semax_pre thm
R6257:6272 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_ifthenelse prfax
R6329:6332 VST.msl.seplog <> ::logic:x_'&&'_x not
R6300:6304 VST.veric.SeparationLogic <> local def
R6307:6308 VST.veric.lift LiftNotation :::'`('_x_')' not
R6313:6327 VST.veric.lift LiftNotation :::'`('_x_')' not
R6309:6310 Coq.Init.Logic <> eq ind
R6316:6324 VST.veric.expr <> eval_expr def
R6333:6337 VST.floyd.canon <> PROPx def
R6342:6347 VST.floyd.canon <> LOCALx def
R6352:6355 VST.floyd.canon <> SEPx def
R6371:6380 VST.msl.seplog <> andp_right meth
R6371:6380 VST.msl.seplog <> andp_right meth
R6405:6414 VST.msl.seplog <> andp_right meth
R6405:6414 VST.msl.seplog <> andp_right meth
R6440:6449 VST.msl.seplog <> andp_left2 meth
R6440:6449 VST.msl.seplog <> andp_left2 meth
R6466:6474 VST.floyd.canon <> semax_pre thm
R6466:6474 VST.floyd.canon <> semax_pre thm
R6507:6517 VST.floyd.canon <> insert_prop thm
R6507:6517 VST.floyd.canon <> insert_prop thm
R6507:6517 VST.floyd.canon <> insert_prop thm
R6530:6534 VST.floyd.canon <> PROPx def
R6539:6544 VST.floyd.canon <> LOCALx def
R6549:6552 VST.floyd.canon <> SEPx def
R6530:6534 VST.floyd.canon <> PROPx def
R6539:6544 VST.floyd.canon <> LOCALx def
R6549:6552 VST.floyd.canon <> SEPx def
R6596:6605 VST.msl.seplog <> andp_right meth
R6596:6605 VST.msl.seplog <> andp_right meth
R6628:6637 VST.msl.seplog <> prop_right meth
R6628:6637 VST.msl.seplog <> prop_right meth
R6668:6676 VST.floyd.canon <> semax_pre thm
R6668:6676 VST.floyd.canon <> semax_pre thm
R6709:6719 VST.floyd.canon <> insert_prop thm
R6709:6719 VST.floyd.canon <> insert_prop thm
R6709:6719 VST.floyd.canon <> insert_prop thm
R6732:6736 VST.floyd.canon <> PROPx def
R6741:6746 VST.floyd.canon <> LOCALx def
R6751:6754 VST.floyd.canon <> SEPx def
R6732:6736 VST.floyd.canon <> PROPx def
R6741:6746 VST.floyd.canon <> LOCALx def
R6751:6754 VST.floyd.canon <> SEPx def
R6798:6807 VST.msl.seplog <> andp_right meth
R6798:6807 VST.msl.seplog <> andp_right meth
R6830:6839 VST.msl.seplog <> prop_right meth
R6830:6839 VST.msl.seplog <> prop_right meth
def 6879:6896 <> logical_and_result
binder 6898:6899 <> v1:76
binder 6901:6902 <> t1:77
binder 6904:6905 <> v2:78
binder 6907:6908 <> t2:79
R6920:6934 VST.veric.mpred <> strict_bool_val def
R6939:6940 VST.floyd.forward_lemmas <> v1:76 var
R6936:6937 VST.floyd.forward_lemmas <> t1:77 var
R6950:6953 Coq.Init.Datatypes <> Some constr
R7206:7209 compcert.common.Values <> Vint constr
R7211:7218 compcert.lib.Integers Int zero def
R6979:6993 VST.veric.mpred <> strict_bool_val def
R6998:6999 VST.floyd.forward_lemmas <> v2:78 var
R6995:6996 VST.floyd.forward_lemmas <> t2:79 var
R7037:7040 Coq.Init.Datatypes <> Some constr
R7119:7122 compcert.common.Values <> Vint constr
R7124:7131 compcert.lib.Integers Int zero def
R7060:7063 compcert.common.Values <> Vint constr
R7065:7071 compcert.lib.Integers Int one def
R7163:7166 Coq.Init.Datatypes <> None constr
R7171:7176 compcert.common.Values <> Vundef constr
R7222:7225 Coq.Init.Datatypes <> None constr
R7230:7235 compcert.common.Values <> Vundef constr
def 7254:7270 <> logical_or_result
binder 7272:7273 <> v1:80
binder 7275:7276 <> t1:81
binder 7278:7279 <> v2:82
binder 7281:7282 <> t2:83
R7294:7308 VST.veric.mpred <> strict_bool_val def
R7313:7314 VST.floyd.forward_lemmas <> v1:80 var
R7310:7311 VST.floyd.forward_lemmas <> t1:81 var
R7324:7327 Coq.Init.Datatypes <> Some constr
R7390:7404 VST.veric.mpred <> strict_bool_val def
R7409:7410 VST.floyd.forward_lemmas <> v2:82 var
R7406:7407 VST.floyd.forward_lemmas <> t2:83 var
R7448:7451 Coq.Init.Datatypes <> Some constr
R7530:7533 compcert.common.Values <> Vint constr
R7535:7542 compcert.lib.Integers Int zero def
R7471:7474 compcert.common.Values <> Vint constr
R7476:7482 compcert.lib.Integers Int one def
R7574:7577 Coq.Init.Datatypes <> None constr
R7582:7587 compcert.common.Values <> Vundef constr
R7346:7349 compcert.common.Values <> Vint constr
R7351:7357 compcert.lib.Integers Int one def
R7595:7598 Coq.Init.Datatypes <> None constr
R7603:7608 compcert.common.Values <> Vundef constr
def 7864:7873 <> logical_or
binder 7875:7877 <> tid:84
binder 7879:7880 <> e1:85
binder 7882:7883 <> e2:86
R7889:7899 compcert.cfrontend.Clight <> Sifthenelse constr
R7973:7981 compcert.cfrontend.Clight <> Ssequence constr
R8044:8047 compcert.cfrontend.Clight <> Sset constr
R8054:8058 compcert.cfrontend.Clight <> Ecast constr
R8090:8093 compcert.exportclight.Clightdefs <> tint def
R8061:8068 compcert.cfrontend.Clight <> Etempvar constr
R8074:8077 compcert.exportclight.Clightdefs <> tint def
R8070:8072 VST.floyd.forward_lemmas <> tid:84 var
R8049:8051 VST.floyd.forward_lemmas <> tid:84 var
R8000:8003 compcert.cfrontend.Clight <> Sset constr
R8010:8014 compcert.cfrontend.Clight <> Ecast constr
R8019:8023 compcert.exportclight.Clightdefs <> tbool def
R8016:8017 VST.floyd.forward_lemmas <> e2:86 var
R8005:8007 VST.floyd.forward_lemmas <> tid:84 var
R7918:7921 compcert.cfrontend.Clight <> Sset constr
R7928:7937 compcert.cfrontend.Clight <> Econst_int constr
R7952:7955 compcert.exportclight.Clightdefs <> tint def
R7940:7947 compcert.lib.Integers Int repr def
R7923:7925 VST.floyd.forward_lemmas <> tid:84 var
R7901:7902 VST.floyd.forward_lemmas <> e1:85 var
def 8114:8124 <> logical_and
binder 8126:8128 <> tid:87
binder 8130:8131 <> e1:88
binder 8133:8134 <> e2:89
R8140:8150 compcert.cfrontend.Clight <> Sifthenelse constr
R8302:8305 compcert.cfrontend.Clight <> Sset constr
R8312:8321 compcert.cfrontend.Clight <> Econst_int constr
R8336:8339 compcert.exportclight.Clightdefs <> tint def
R8324:8331 compcert.lib.Integers Int repr def
R8307:8309 VST.floyd.forward_lemmas <> tid:87 var
R8168:8176 compcert.cfrontend.Clight <> Ssequence constr
R8235:8238 compcert.cfrontend.Clight <> Sset constr
R8245:8249 compcert.cfrontend.Clight <> Ecast constr
R8281:8284 compcert.exportclight.Clightdefs <> tint def
R8252:8259 compcert.cfrontend.Clight <> Etempvar constr
R8265:8268 compcert.exportclight.Clightdefs <> tint def
R8261:8263 VST.floyd.forward_lemmas <> tid:87 var
R8240:8242 VST.floyd.forward_lemmas <> tid:87 var
R8193:8196 compcert.cfrontend.Clight <> Sset constr
R8203:8207 compcert.cfrontend.Clight <> Ecast constr
R8212:8216 compcert.exportclight.Clightdefs <> tbool def
R8209:8210 VST.floyd.forward_lemmas <> e2:89 var
R8198:8200 VST.floyd.forward_lemmas <> tid:87 var
R8152:8153 VST.floyd.forward_lemmas <> e1:88 var
prf 8352:8368 <> semax_pre_flipped
R8393:8396 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R8397:8401 VST.veric.mpred <> mpred def
R8386:8392 VST.veric.mpred <> environ ind
binder 8381:8382 <> P':90
R8413:8422 VST.veric.juicy_extspec <> OracleKind class
binder 8405:8409 <> Espec:91
R8430:8438 VST.veric.mpred <> compspecs class
binder 8426:8427 <> cs:92
R8459:8467 VST.veric.seplog <> tycontext ind
binder 8451:8455 <> Delta:93
R8476:8479 Coq.Init.Datatypes <> list ind
binder 8471:8472 <> P1:94
R8493:8496 Coq.Init.Datatypes <> list ind
R8498:8505 VST.floyd.canon <> localdef ind
binder 8488:8489 <> P2:95
R8523:8526 Coq.Init.Datatypes <> list ind
R8528:8532 VST.veric.mpred <> mpred def
binder 8518:8519 <> P3:96
R8540:8548 compcert.cfrontend.Clight <> statement ind
binder 8536:8536 <> c:97
R8565:8574 VST.veric.tycontext <> ret_assert rec
binder 8561:8561 <> R:98
R8603:8613 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R8665:8676 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R8677:8681 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R8724:8724 VST.floyd.forward_lemmas <> R:98 var
R8722:8722 VST.floyd.forward_lemmas <> c:97 var
R8690:8694 VST.floyd.canon <> PROPx def
R8700:8705 VST.floyd.canon <> LOCALx def
R8711:8714 VST.floyd.canon <> SEPx def
R8716:8717 VST.floyd.forward_lemmas <> P3:96 var
R8707:8708 VST.floyd.forward_lemmas <> P2:95 var
R8696:8697 VST.floyd.forward_lemmas <> P1:94 var
R8683:8687 VST.floyd.forward_lemmas <> Delta:93 var
R8614:8620 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R8626:8627 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R8658:8662 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R8621:8625 VST.floyd.forward_lemmas <> Delta:93 var
R8628:8632 VST.floyd.canon <> PROPx def
R8638:8643 VST.floyd.canon <> LOCALx def
R8649:8652 VST.floyd.canon <> SEPx def
R8654:8655 VST.floyd.forward_lemmas <> P3:96 var
R8645:8646 VST.floyd.forward_lemmas <> P2:95 var
R8634:8635 VST.floyd.forward_lemmas <> P1:94 var
R8663:8664 VST.floyd.forward_lemmas <> P':90 var
R8585:8589 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R8602:8602 VST.floyd.forward_lemmas <> R:98 var
R8600:8600 VST.floyd.forward_lemmas <> c:97 var
R8597:8598 VST.floyd.forward_lemmas <> P':90 var
R8591:8595 VST.floyd.forward_lemmas <> Delta:93 var
R8749:8757 VST.floyd.canon <> semax_pre thm
R8749:8757 VST.floyd.canon <> semax_pre thm
prf 8788:8798 <> semax_while
binder 8810:8814 <> Espec:99
R8821:8829 VST.veric.mpred <> compspecs class
binder 8817:8818 <> cs:100
binder 8832:8836 <> Delta:101
binder 8838:8838 <> Q:102
binder 8840:8843 <> test:103
binder 8845:8848 <> body:104
R8854:8863 VST.veric.tycontext <> ret_assert rec
binder 8851:8851 <> R:105
R8902:8910 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R8911:8911 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R8993:9002 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R9003:9003 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R9111:9120 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R9231:9239 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R9241:9245 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R9283:9283 VST.floyd.forward_lemmas <> R:105 var
R9265:9270 compcert.cfrontend.Clight <> Swhile def
R9277:9280 VST.floyd.forward_lemmas <> body:104 var
R9272:9275 VST.floyd.forward_lemmas <> test:103 var
R9262:9262 VST.floyd.forward_lemmas <> Q:102 var
R9256:9260 VST.floyd.forward_lemmas <> Delta:101 var
R9250:9254 VST.floyd.forward_lemmas <> Espec:99 var
R9247:9248 VST.floyd.forward_lemmas <> cs:100 var
R9122:9126 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R9210:9225 VST.veric.SeparationLogic <> loop1_ret_assert def
R9229:9229 VST.floyd.forward_lemmas <> R:105 var
R9227:9227 VST.floyd.forward_lemmas <> Q:102 var
R9204:9207 VST.floyd.forward_lemmas <> body:104 var
R9196:9199 VST.msl.seplog <> ::logic:x_'&&'_x not
R9144:9148 VST.veric.SeparationLogic <> local def
R9151:9152 VST.veric.lift LiftNotation :::'`('_x_')' not
R9177:9194 VST.veric.lift LiftNotation :::'`('_x_')' not
R9153:9162 VST.veric.SeparationLogic <> typed_true def
R9165:9170 compcert.cfrontend.Clight <> typeof def
R9172:9175 VST.floyd.forward_lemmas <> test:103 var
R9180:9188 VST.veric.expr <> eval_expr def
R9190:9193 VST.floyd.forward_lemmas <> test:103 var
R9200:9200 VST.floyd.forward_lemmas <> Q:102 var
R9137:9141 VST.floyd.forward_lemmas <> Delta:101 var
R9131:9135 VST.floyd.forward_lemmas <> Espec:99 var
R9128:9129 VST.floyd.forward_lemmas <> cs:100 var
R9095:9099 VST.msl.seplog <> ::logic_derives:x_'|--'_x not
R9090:9093 VST.msl.seplog <> ::logic:x_'&&'_x not
R9028:9031 VST.msl.seplog <> ::logic:x_'&&'_x not
R9004:9008 VST.veric.SeparationLogic <> local def
R9011:9020 VST.veric.SeparationLogic <> tc_environ def
R9022:9026 VST.floyd.forward_lemmas <> Delta:101 var
R9032:9036 VST.veric.SeparationLogic <> local def
R9039:9043 VST.veric.mpred <> lift1 def
R9074:9082 VST.veric.expr <> eval_expr def
R9084:9087 VST.floyd.forward_lemmas <> test:103 var
R9046:9056 VST.veric.SeparationLogic <> typed_false def
R9059:9064 compcert.cfrontend.Clight <> typeof def
R9066:9069 VST.floyd.forward_lemmas <> test:103 var
R9094:9094 VST.floyd.forward_lemmas <> Q:102 var
R9100:9108 VST.veric.tycontext <> RA_normal proj
R9110:9110 VST.floyd.forward_lemmas <> R:105 var
R8941:8947 VST.msl.seplog <> ::logic_derives:x_'|--'_x not
R8992:8992 VST.msl.seplog <> ::logic_derives:x_'|--'_x not
R8936:8939 VST.msl.seplog <> ::logic:x_'&&'_x not
R8912:8916 VST.veric.SeparationLogic <> local def
R8919:8928 VST.veric.SeparationLogic <> tc_environ def
R8930:8934 VST.floyd.forward_lemmas <> Delta:101 var
R8940:8940 VST.floyd.forward_lemmas <> Q:102 var
R8948:8954 VST.veric.SeparationLogic <> tc_expr def
R8963:8967 compcert.cfrontend.Clight <> Eunop constr
R8987:8990 compcert.exportclight.Clightdefs <> tint def
R8982:8985 VST.floyd.forward_lemmas <> test:103 var
R8969:8980 compcert.cfrontend.Cop <> Onotbool constr
R8956:8960 VST.floyd.forward_lemmas <> Delta:101 var
R8895:8897 Coq.Init.Logic <> ::type_scope:x_'='_x not
R8872:8880 VST.veric.expr <> bool_type def
R8883:8888 compcert.cfrontend.Clight <> typeof def
R8890:8893 VST.floyd.forward_lemmas <> test:103 var
R8898:8901 Coq.Init.Datatypes <> true constr
R9335:9340 compcert.cfrontend.Clight <> Swhile def
R9351:9360 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_loop prfax
R9351:9360 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_loop prfax
R9402:9419 VST.floyd.canon <> semax_post_flipped thm
R9402:9419 VST.floyd.canon <> semax_post_flipped thm
R9428:9437 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_skip prfax
R9428:9437 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_skip prfax
R9465:9474 VST.msl.seplog <> andp_left2 meth
R9495:9506 VST.msl.seplog <> derives_refl meth
R9465:9474 VST.msl.seplog <> andp_left2 meth
R9495:9506 VST.msl.seplog <> derives_refl meth
R9465:9474 VST.msl.seplog <> andp_left2 meth
R9495:9506 VST.msl.seplog <> derives_refl meth
R9465:9474 VST.msl.seplog <> andp_left2 meth
R9495:9506 VST.msl.seplog <> derives_refl meth
R9465:9474 VST.msl.seplog <> andp_left2 meth
R9495:9506 VST.msl.seplog <> derives_refl meth
R9525:9534 VST.msl.seplog <> andp_left2 meth
R9525:9534 VST.msl.seplog <> andp_left2 meth
R9582:9591 VST.msl.seplog <> andp_left2 meth
R9582:9591 VST.msl.seplog <> andp_left2 meth
R9702:9705 VST.msl.seplog <> ::logic:x_'&&'_x not
R9650:9654 VST.veric.SeparationLogic <> local def
R9657:9658 VST.veric.lift LiftNotation :::'`('_x_')' not
R9683:9700 VST.veric.lift LiftNotation :::'`('_x_')' not
R9659:9668 VST.veric.SeparationLogic <> typed_true def
R9671:9676 compcert.cfrontend.Clight <> typeof def
R9686:9694 VST.veric.expr <> eval_expr def
R9633:9641 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_seq prfax
R9702:9705 VST.msl.seplog <> ::logic:x_'&&'_x not
R9650:9654 VST.veric.SeparationLogic <> local def
R9657:9658 VST.veric.lift LiftNotation :::'`('_x_')' not
R9683:9700 VST.veric.lift LiftNotation :::'`('_x_')' not
R9659:9668 VST.veric.SeparationLogic <> typed_true def
R9671:9676 compcert.cfrontend.Clight <> typeof def
R9686:9694 VST.veric.expr <> eval_expr def
R9633:9641 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_seq prfax
R9740:9740 VST.msl.seplog <> ::logic:x_'&&'_x not
R9785:9789 VST.msl.seplog <> ::logic:x_'&&'_x not
R9741:9747 VST.veric.SeparationLogic <> tc_expr def
R9756:9760 compcert.cfrontend.Clight <> Eunop constr
R9780:9783 compcert.exportclight.Clightdefs <> tint def
R9762:9773 compcert.cfrontend.Cop <> Onotbool constr
R9716:9731 VST.floyd.canon <> semax_pre_simple thm
R9740:9740 VST.msl.seplog <> ::logic:x_'&&'_x not
R9785:9789 VST.msl.seplog <> ::logic:x_'&&'_x not
R9741:9747 VST.veric.SeparationLogic <> tc_expr def
R9756:9760 compcert.cfrontend.Clight <> Eunop constr
R9780:9783 compcert.exportclight.Clightdefs <> tint def
R9762:9773 compcert.cfrontend.Cop <> Onotbool constr
R9716:9731 VST.floyd.canon <> semax_pre_simple thm
R9800:9809 VST.msl.seplog <> andp_right meth
R9800:9809 VST.msl.seplog <> andp_right meth
R9828:9837 VST.msl.seplog <> andp_left2 meth
R9828:9837 VST.msl.seplog <> andp_left2 meth
R9868:9883 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_ifthenelse prfax
R9868:9883 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_ifthenelse prfax
R9899:9916 VST.floyd.canon <> semax_post_flipped thm
R9899:9916 VST.floyd.canon <> semax_post_flipped thm
R9925:9934 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_skip prfax
R9925:9934 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_skip prfax
R9994:10003 VST.msl.seplog <> andp_left2 meth
R9994:10003 VST.msl.seplog <> andp_left2 meth
R10032:10040 VST.msl.log_normalize <> andp_comm thm
R10032:10040 VST.msl.log_normalize <> andp_comm thm
R10032:10040 VST.msl.log_normalize <> andp_comm thm
R10096:10111 VST.floyd.canon <> semax_pre_simple thm
R10124:10134 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_break prfax
R10096:10111 VST.floyd.canon <> semax_pre_simple thm
R10124:10134 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_break prfax
R10147:10155 VST.msl.log_normalize <> andp_comm thm
R10147:10155 VST.msl.log_normalize <> andp_comm thm
R10147:10155 VST.msl.log_normalize <> andp_comm thm
R10172:10181 VST.msl.log_normalize <> andp_assoc thm
R10172:10181 VST.msl.log_normalize <> andp_assoc thm
R10172:10181 VST.msl.log_normalize <> andp_assoc thm
R10191:10203 VST.msl.seplog <> derives_trans meth
R10191:10203 VST.msl.seplog <> derives_trans meth
prf 10265:10279 <> semax_while_3g1
binder 10291:10295 <> Espec:106
R10302:10310 VST.veric.mpred <> compspecs class
binder 10298:10299 <> cs:107
binder 10314:10314 <> A:108
R10322:10325 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R10326:10328 compcert.common.Values <> val ind
R10321:10321 VST.floyd.forward_lemmas <> A:108 var
binder 10318:10318 <> v:109
binder 10331:10335 <> Delta:110
binder 10337:10337 <> P:111
binder 10339:10339 <> Q:112
binder 10341:10341 <> R:113
binder 10343:10346 <> test:114
binder 10348:10351 <> body:115
binder 10353:10356 <> Post:116
R10394:10402 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R10403:10403 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R10518:10527 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R10528:10528 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R10633:10642 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R10643:10643 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R11033:11042 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R11044:11048 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R11169:11180 VST.veric.SeparationLogic <> overridePost def
R11306:11309 VST.floyd.forward_lemmas <> Post:116 var
R11202:11204 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R11208:11209 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R11207:11207 VST.floyd.forward_lemmas <> A:108 var
binder 11205:11205 <> a:117
R11210:11214 VST.floyd.canon <> PROPx def
R11259:11264 VST.floyd.canon <> LOCALx def
R11273:11276 VST.floyd.canon <> SEPx def
R11279:11279 VST.floyd.forward_lemmas <> R:113 var
R11281:11281 VST.floyd.forward_lemmas <> a:117 var
R11267:11267 VST.floyd.forward_lemmas <> Q:112 var
R11269:11269 VST.floyd.forward_lemmas <> a:117 var
R11248:11251 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R11217:11227 VST.veric.SeparationLogic <> typed_false def
R11244:11244 VST.floyd.forward_lemmas <> v:109 var
R11246:11246 VST.floyd.forward_lemmas <> a:117 var
R11230:11235 compcert.cfrontend.Clight <> typeof def
R11237:11240 VST.floyd.forward_lemmas <> test:114 var
R11252:11252 VST.floyd.forward_lemmas <> P:111 var
R11254:11254 VST.floyd.forward_lemmas <> a:117 var
R11133:11138 compcert.cfrontend.Clight <> Swhile def
R11145:11148 VST.floyd.forward_lemmas <> body:115 var
R11140:11143 VST.floyd.forward_lemmas <> test:114 var
R11066:11068 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R11072:11073 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R11071:11071 VST.floyd.forward_lemmas <> A:108 var
binder 11069:11069 <> a:118
R11074:11078 VST.floyd.canon <> PROPx def
R11087:11092 VST.floyd.canon <> LOCALx def
R11101:11104 VST.floyd.canon <> SEPx def
R11107:11107 VST.floyd.forward_lemmas <> R:113 var
R11109:11109 VST.floyd.forward_lemmas <> a:118 var
R11095:11095 VST.floyd.forward_lemmas <> Q:112 var
R11097:11097 VST.floyd.forward_lemmas <> a:118 var
R11081:11081 VST.floyd.forward_lemmas <> P:111 var
R11083:11083 VST.floyd.forward_lemmas <> a:118 var
R11059:11063 VST.floyd.forward_lemmas <> Delta:110 var
R11053:11057 VST.floyd.forward_lemmas <> Espec:106 var
R11050:11051 VST.floyd.forward_lemmas <> cs:107 var
binder 10651:10651 <> a:119
R10655:10659 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R10777:10792 VST.veric.SeparationLogic <> loop1_ret_assert def
R10872:10883 VST.veric.SeparationLogic <> overridePost def
R11027:11030 VST.floyd.forward_lemmas <> Post:116 var
R10914:10916 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R10920:10921 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R10919:10919 VST.floyd.forward_lemmas <> A:108 var
binder 10917:10917 <> a:120
R10922:10926 VST.floyd.canon <> PROPx def
R10971:10976 VST.floyd.canon <> LOCALx def
R10985:10988 VST.floyd.canon <> SEPx def
R10991:10991 VST.floyd.forward_lemmas <> R:113 var
R10993:10993 VST.floyd.forward_lemmas <> a:120 var
R10979:10979 VST.floyd.forward_lemmas <> Q:112 var
R10981:10981 VST.floyd.forward_lemmas <> a:120 var
R10960:10963 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R10929:10939 VST.veric.SeparationLogic <> typed_false def
R10956:10956 VST.floyd.forward_lemmas <> v:109 var
R10958:10958 VST.floyd.forward_lemmas <> a:120 var
R10942:10947 compcert.cfrontend.Clight <> typeof def
R10949:10952 VST.floyd.forward_lemmas <> test:114 var
R10964:10964 VST.floyd.forward_lemmas <> P:111 var
R10966:10966 VST.floyd.forward_lemmas <> a:120 var
R10795:10797 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R10801:10802 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R10800:10800 VST.floyd.forward_lemmas <> A:108 var
binder 10798:10798 <> a:121
R10803:10807 VST.floyd.canon <> PROPx def
R10816:10821 VST.floyd.canon <> LOCALx def
R10830:10833 VST.floyd.canon <> SEPx def
R10836:10836 VST.floyd.forward_lemmas <> R:113 var
R10838:10838 VST.floyd.forward_lemmas <> a:121 var
R10824:10824 VST.floyd.forward_lemmas <> Q:112 var
R10826:10826 VST.floyd.forward_lemmas <> a:121 var
R10810:10810 VST.floyd.forward_lemmas <> P:111 var
R10812:10812 VST.floyd.forward_lemmas <> a:121 var
R10771:10774 VST.floyd.forward_lemmas <> body:115 var
R10677:10681 VST.floyd.canon <> PROPx def
R10726:10731 VST.floyd.canon <> LOCALx def
R10740:10743 VST.floyd.canon <> SEPx def
R10746:10746 VST.floyd.forward_lemmas <> R:113 var
R10748:10748 VST.floyd.forward_lemmas <> a:119 var
R10734:10734 VST.floyd.forward_lemmas <> Q:112 var
R10736:10736 VST.floyd.forward_lemmas <> a:119 var
R10714:10718 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R10722:10722 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R10684:10693 VST.veric.SeparationLogic <> typed_true def
R10710:10710 VST.floyd.forward_lemmas <> v:109 var
R10712:10712 VST.floyd.forward_lemmas <> a:119 var
R10696:10701 compcert.cfrontend.Clight <> typeof def
R10703:10706 VST.floyd.forward_lemmas <> test:114 var
R10719:10719 VST.floyd.forward_lemmas <> P:111 var
R10721:10721 VST.floyd.forward_lemmas <> a:119 var
R10670:10674 VST.floyd.forward_lemmas <> Delta:110 var
R10664:10668 VST.floyd.forward_lemmas <> Espec:106 var
R10661:10662 VST.floyd.forward_lemmas <> cs:107 var
binder 10536:10536 <> a:122
R10539:10545 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R10551:10552 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R10592:10596 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R10546:10550 VST.floyd.forward_lemmas <> Delta:110 var
R10553:10557 VST.floyd.canon <> PROPx def
R10566:10571 VST.floyd.canon <> LOCALx def
R10580:10583 VST.floyd.canon <> SEPx def
R10586:10586 VST.floyd.forward_lemmas <> R:113 var
R10588:10588 VST.floyd.forward_lemmas <> a:122 var
R10574:10574 VST.floyd.forward_lemmas <> Q:112 var
R10576:10576 VST.floyd.forward_lemmas <> a:122 var
R10560:10560 VST.floyd.forward_lemmas <> P:111 var
R10562:10562 VST.floyd.forward_lemmas <> a:122 var
R10597:10601 VST.veric.SeparationLogic <> local def
R10604:10605 VST.veric.lift LiftNotation :::'`('_x_')' not
R10614:10631 VST.veric.lift LiftNotation :::'`('_x_')' not
R10606:10607 Coq.Init.Logic <> eq ind
R10610:10610 VST.floyd.forward_lemmas <> v:109 var
R10612:10612 VST.floyd.forward_lemmas <> a:122 var
R10617:10625 VST.veric.expr <> eval_expr def
R10627:10630 VST.floyd.forward_lemmas <> test:114 var
binder 10411:10411 <> a:123
R10414:10420 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R10426:10427 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R10467:10472 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R10517:10517 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R10421:10425 VST.floyd.forward_lemmas <> Delta:110 var
R10428:10432 VST.floyd.canon <> PROPx def
R10441:10446 VST.floyd.canon <> LOCALx def
R10455:10458 VST.floyd.canon <> SEPx def
R10461:10461 VST.floyd.forward_lemmas <> R:113 var
R10463:10463 VST.floyd.forward_lemmas <> a:123 var
R10449:10449 VST.floyd.forward_lemmas <> Q:112 var
R10451:10451 VST.floyd.forward_lemmas <> a:123 var
R10435:10435 VST.floyd.forward_lemmas <> P:111 var
R10437:10437 VST.floyd.forward_lemmas <> a:123 var
R10473:10479 VST.veric.SeparationLogic <> tc_expr def
R10488:10492 compcert.cfrontend.Clight <> Eunop constr
R10512:10515 compcert.exportclight.Clightdefs <> tint def
R10507:10510 VST.floyd.forward_lemmas <> test:114 var
R10494:10505 compcert.cfrontend.Cop <> Onotbool constr
R10481:10485 VST.floyd.forward_lemmas <> Delta:110 var
R10387:10389 Coq.Init.Logic <> ::type_scope:x_'='_x not
R10364:10372 VST.veric.expr <> bool_type def
R10375:10380 compcert.cfrontend.Clight <> typeof def
R10382:10385 VST.floyd.forward_lemmas <> test:114 var
R10390:10393 Coq.Init.Datatypes <> true constr
R11334:11344 VST.floyd.forward_lemmas <> semax_while thm
R11334:11344 VST.floyd.forward_lemmas <> semax_while thm
R11364:11372 VST.msl.log_normalize <> exp_andp2 thm
R11364:11372 VST.msl.log_normalize <> exp_andp2 thm
R11364:11372 VST.msl.log_normalize <> exp_andp2 thm
R11381:11388 VST.msl.seplog <> exp_left meth
R11381:11388 VST.msl.seplog <> exp_left meth
R11408:11420 VST.msl.seplog <> derives_trans meth
R11408:11420 VST.msl.seplog <> derives_trans meth
R11445:11456 VST.msl.seplog <> derives_refl meth
R11445:11456 VST.msl.seplog <> derives_refl meth
R11476:11484 VST.msl.log_normalize <> exp_andp2 thm
R11476:11484 VST.msl.log_normalize <> exp_andp2 thm
R11476:11484 VST.msl.log_normalize <> exp_andp2 thm
R11476:11484 VST.msl.log_normalize <> exp_andp2 thm
R11493:11500 VST.msl.seplog <> exp_left meth
R11493:11500 VST.msl.seplog <> exp_left meth
R11520:11539 VST.floyd.assert_lemmas <> overridePost_normal' thm
R11520:11539 VST.floyd.assert_lemmas <> overridePost_normal' thm
R11520:11539 VST.floyd.assert_lemmas <> overridePost_normal' thm
R11548:11556 VST.msl.seplog <> exp_right meth
R11548:11556 VST.msl.seplog <> exp_right meth
R11573:11585 VST.msl.seplog <> derives_trans meth
R11573:11585 VST.msl.seplog <> derives_trans meth
R11594:11603 VST.msl.seplog <> andp_right meth
R11616:11627 VST.msl.seplog <> derives_refl meth
R11594:11603 VST.msl.seplog <> andp_right meth
R11616:11627 VST.msl.seplog <> derives_refl meth
R11638:11650 VST.msl.seplog <> derives_trans meth
R11638:11650 VST.msl.seplog <> derives_trans meth
R11681:11689 VST.msl.log_normalize <> andp_comm thm
R11692:11696 VST.veric.SeparationLogic <> local def
R11681:11689 VST.msl.log_normalize <> andp_comm thm
R11692:11696 VST.veric.SeparationLogic <> local def
R11681:11689 VST.msl.log_normalize <> andp_comm thm
R11692:11696 VST.veric.SeparationLogic <> local def
R11711:11720 VST.msl.log_normalize <> andp_assoc thm
R11711:11720 VST.msl.log_normalize <> andp_assoc thm
R11711:11720 VST.msl.log_normalize <> andp_assoc thm
R11729:11738 VST.msl.seplog <> andp_left2 meth
R11729:11738 VST.msl.seplog <> andp_left2 meth
R11782:11791 VST.msl.seplog <> andp_right meth
R11782:11791 VST.msl.seplog <> andp_right meth
R11782:11791 VST.msl.seplog <> andp_right meth
R11782:11791 VST.msl.seplog <> andp_right meth
R11806:11815 VST.msl.seplog <> prop_right meth
R11806:11815 VST.msl.seplog <> prop_right meth
R11867:11875 VST.msl.log_normalize <> exp_andp2 thm
R11867:11875 VST.msl.log_normalize <> exp_andp2 thm
R11867:11875 VST.msl.log_normalize <> exp_andp2 thm
R11867:11875 VST.msl.log_normalize <> exp_andp2 thm
R11885:11902 VST.floyd.base <> extract_exists_pre def
R11885:11902 VST.floyd.base <> extract_exists_pre def
R11922:11935 VST.floyd.canon <> semax_pre_post thm
R11922:11935 VST.floyd.canon <> semax_pre_post thm
R11971:11980 VST.msl.log_normalize <> andp_assoc thm
R11971:11980 VST.msl.log_normalize <> andp_assoc thm
R11971:11980 VST.msl.log_normalize <> andp_assoc thm
R11995:12005 VST.floyd.canon <> insert_prop thm
R11995:12005 VST.floyd.canon <> insert_prop thm
R11995:12005 VST.floyd.canon <> insert_prop thm
R12015:12024 VST.msl.seplog <> andp_right meth
R12037:12046 VST.msl.seplog <> andp_left2 meth
R12015:12024 VST.msl.seplog <> andp_right meth
R12037:12046 VST.msl.seplog <> andp_left2 meth
R12066:12074 VST.msl.log_normalize <> andp_comm thm
R12077:12081 VST.veric.SeparationLogic <> local def
R12066:12074 VST.msl.log_normalize <> andp_comm thm
R12077:12081 VST.veric.SeparationLogic <> local def
R12066:12074 VST.msl.log_normalize <> andp_comm thm
R12077:12081 VST.veric.SeparationLogic <> local def
R12096:12105 VST.msl.log_normalize <> andp_assoc thm
R12096:12105 VST.msl.log_normalize <> andp_assoc thm
R12096:12105 VST.msl.log_normalize <> andp_assoc thm
R12116:12128 VST.msl.seplog <> derives_trans meth
R12116:12128 VST.msl.seplog <> derives_trans meth
R12138:12147 VST.msl.seplog <> andp_right meth
R12160:12171 VST.msl.seplog <> derives_refl meth
R12138:12147 VST.msl.seplog <> andp_right meth
R12160:12171 VST.msl.seplog <> derives_refl meth
R12182:12191 VST.msl.seplog <> andp_left2 meth
R12182:12191 VST.msl.seplog <> andp_left2 meth
R12220:12229 VST.msl.log_normalize <> andp_assoc thm
R12220:12229 VST.msl.log_normalize <> andp_assoc thm
R12220:12229 VST.msl.log_normalize <> andp_assoc thm
R12239:12248 VST.msl.seplog <> andp_left1 meth
R12239:12248 VST.msl.seplog <> andp_left1 meth
R12276:12285 VST.msl.seplog <> prop_right meth
R12276:12285 VST.msl.seplog <> prop_right meth
R12315:12324 VST.msl.seplog <> andp_left2 meth
R12315:12324 VST.msl.seplog <> andp_left2 meth
R12364:12373 VST.msl.seplog <> andp_left2 meth
R12364:12373 VST.msl.seplog <> andp_left2 meth
R12413:12422 VST.msl.seplog <> andp_left2 meth
R12413:12422 VST.msl.seplog <> andp_left2 meth
R12470:12479 VST.msl.seplog <> andp_left2 meth
R12470:12479 VST.msl.seplog <> andp_left2 meth
prf 12522:12532 <> semax_for_x
binder 12544:12548 <> Espec:124
R12555:12563 VST.veric.mpred <> compspecs class
binder 12551:12552 <> cs:125
binder 12566:12570 <> Delta:126
binder 12572:12572 <> Q:127
binder 12574:12577 <> test:128
binder 12579:12582 <> body:129
binder 12584:12587 <> incr:130
binder 12589:12595 <> PreIncr:131
binder 12597:12600 <> Post:132
R12638:12646 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R12727:12735 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R12853:12861 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R12993:13001 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R13058:13066 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R13068:13072 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R13167:13170 VST.floyd.forward_lemmas <> Post:132 var
R13099:13103 compcert.cfrontend.Clight <> Sloop constr
R13154:13157 VST.floyd.forward_lemmas <> incr:130 var
R13106:13114 compcert.cfrontend.Clight <> Ssequence constr
R13148:13151 VST.floyd.forward_lemmas <> body:129 var
R13117:13127 compcert.cfrontend.Clight <> Sifthenelse constr
R13140:13145 compcert.cfrontend.Clight <> Sbreak constr
R13134:13138 compcert.cfrontend.Clight <> Sskip constr
R13129:13132 VST.floyd.forward_lemmas <> test:128 var
R13089:13089 VST.floyd.forward_lemmas <> Q:127 var
R13083:13087 VST.floyd.forward_lemmas <> Delta:126 var
R13077:13081 VST.floyd.forward_lemmas <> Espec:124 var
R13074:13075 VST.floyd.forward_lemmas <> cs:125 var
R13003:13007 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R13038:13054 VST.veric.SeparationLogic <> normal_ret_assert def
R13056:13056 VST.floyd.forward_lemmas <> Q:127 var
R13032:13035 VST.floyd.forward_lemmas <> incr:130 var
R13024:13030 VST.floyd.forward_lemmas <> PreIncr:131 var
R13018:13022 VST.floyd.forward_lemmas <> Delta:126 var
R13012:13016 VST.floyd.forward_lemmas <> Espec:124 var
R13009:13010 VST.floyd.forward_lemmas <> cs:125 var
R12863:12867 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R12963:12978 VST.veric.SeparationLogic <> loop1_ret_assert def
R12988:12991 VST.floyd.forward_lemmas <> Post:132 var
R12980:12986 VST.floyd.forward_lemmas <> PreIncr:131 var
R12957:12960 VST.floyd.forward_lemmas <> body:129 var
R12937:12940 VST.msl.seplog <> ::logic:x_'&&'_x not
R12885:12889 VST.veric.SeparationLogic <> local def
R12892:12893 VST.veric.lift LiftNotation :::'`('_x_')' not
R12918:12935 VST.veric.lift LiftNotation :::'`('_x_')' not
R12894:12903 VST.veric.SeparationLogic <> typed_true def
R12906:12911 compcert.cfrontend.Clight <> typeof def
R12913:12916 VST.floyd.forward_lemmas <> test:128 var
R12921:12929 VST.veric.expr <> eval_expr def
R12931:12934 VST.floyd.forward_lemmas <> test:128 var
R12941:12941 VST.floyd.forward_lemmas <> Q:127 var
R12878:12882 VST.floyd.forward_lemmas <> Delta:126 var
R12872:12876 VST.floyd.forward_lemmas <> Espec:124 var
R12869:12870 VST.floyd.forward_lemmas <> cs:125 var
R12834:12838 VST.msl.seplog <> ::logic_derives:x_'|--'_x not
R12823:12832 VST.msl.seplog <> ::logic:x_'&&'_x not
R12760:12769 VST.msl.seplog <> ::logic:x_'&&'_x not
R12736:12740 VST.veric.SeparationLogic <> local def
R12743:12752 VST.veric.SeparationLogic <> tc_environ def
R12754:12758 VST.floyd.forward_lemmas <> Delta:126 var
R12770:12774 VST.veric.SeparationLogic <> local def
R12777:12778 VST.veric.lift LiftNotation :::'`('_x_')' not
R12804:12821 VST.veric.lift LiftNotation :::'`('_x_')' not
R12779:12789 VST.veric.SeparationLogic <> typed_false def
R12792:12797 compcert.cfrontend.Clight <> typeof def
R12799:12802 VST.floyd.forward_lemmas <> test:128 var
R12807:12815 VST.veric.expr <> eval_expr def
R12817:12820 VST.floyd.forward_lemmas <> test:128 var
R12833:12833 VST.floyd.forward_lemmas <> Q:127 var
R12839:12847 VST.veric.tycontext <> RA_normal proj
R12849:12852 VST.floyd.forward_lemmas <> Post:132 var
R12676:12681 VST.msl.seplog <> ::logic_derives:x_'|--'_x not
R12726:12726 VST.msl.seplog <> ::logic_derives:x_'|--'_x not
R12671:12674 VST.msl.seplog <> ::logic:x_'&&'_x not
R12647:12651 VST.veric.SeparationLogic <> local def
R12654:12663 VST.veric.SeparationLogic <> tc_environ def
R12665:12669 VST.floyd.forward_lemmas <> Delta:126 var
R12675:12675 VST.floyd.forward_lemmas <> Q:127 var
R12682:12688 VST.veric.SeparationLogic <> tc_expr def
R12697:12701 compcert.cfrontend.Clight <> Eunop constr
R12721:12724 compcert.exportclight.Clightdefs <> tint def
R12716:12719 VST.floyd.forward_lemmas <> test:128 var
R12703:12714 compcert.cfrontend.Cop <> Onotbool constr
R12690:12694 VST.floyd.forward_lemmas <> Delta:126 var
R12631:12633 Coq.Init.Logic <> ::type_scope:x_'='_x not
R12608:12616 VST.veric.expr <> bool_type def
R12619:12624 compcert.cfrontend.Clight <> typeof def
R12626:12629 VST.floyd.forward_lemmas <> test:128 var
R12634:12637 Coq.Init.Datatypes <> true constr
R13194:13203 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_loop prfax
R13194:13203 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_loop prfax
R13265:13272 VST.msl.seplog <> ::logic:x_'&&'_x not
R13331:13331 VST.msl.seplog <> ::logic:x_'&&'_x not
R13241:13245 VST.veric.SeparationLogic <> local def
R13248:13257 VST.veric.SeparationLogic <> tc_environ def
R13274:13277 VST.msl.seplog <> ::logic:x_'&&'_x not
R13278:13282 VST.veric.SeparationLogic <> local def
R13285:13287 VST.veric.lift LiftNotation :::'`'_x not
R13312:13329 VST.veric.lift LiftNotation :::'`'_x not
R13288:13297 VST.veric.SeparationLogic <> typed_true def
R13300:13305 compcert.cfrontend.Clight <> typeof def
R13315:13323 VST.veric.expr <> eval_expr def
R13225:13233 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_seq prfax
R13265:13272 VST.msl.seplog <> ::logic:x_'&&'_x not
R13331:13331 VST.msl.seplog <> ::logic:x_'&&'_x not
R13241:13245 VST.veric.SeparationLogic <> local def
R13248:13257 VST.veric.SeparationLogic <> tc_environ def
R13274:13277 VST.msl.seplog <> ::logic:x_'&&'_x not
R13278:13282 VST.veric.SeparationLogic <> local def
R13285:13287 VST.veric.lift LiftNotation :::'`'_x not
R13312:13329 VST.veric.lift LiftNotation :::'`'_x not
R13288:13297 VST.veric.SeparationLogic <> typed_true def
R13300:13305 compcert.cfrontend.Clight <> typeof def
R13315:13323 VST.veric.expr <> eval_expr def
R13225:13233 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_seq prfax
R13367:13367 VST.msl.seplog <> ::logic:x_'&&'_x not
R13412:13416 VST.msl.seplog <> ::logic:x_'&&'_x not
R13368:13374 VST.veric.SeparationLogic <> tc_expr def
R13383:13387 compcert.cfrontend.Clight <> Eunop constr
R13407:13410 compcert.exportclight.Clightdefs <> tint def
R13389:13400 compcert.cfrontend.Cop <> Onotbool constr
R13342:13357 VST.floyd.canon <> semax_pre_simple thm
R13367:13367 VST.msl.seplog <> ::logic:x_'&&'_x not
R13412:13416 VST.msl.seplog <> ::logic:x_'&&'_x not
R13368:13374 VST.veric.SeparationLogic <> tc_expr def
R13383:13387 compcert.cfrontend.Clight <> Eunop constr
R13407:13410 compcert.exportclight.Clightdefs <> tint def
R13389:13400 compcert.cfrontend.Cop <> Onotbool constr
R13342:13357 VST.floyd.canon <> semax_pre_simple thm
R13427:13436 VST.msl.seplog <> andp_right meth
R13427:13436 VST.msl.seplog <> andp_right meth
R13451:13460 VST.msl.seplog <> andp_left2 meth
R13451:13460 VST.msl.seplog <> andp_left2 meth
R13475:13490 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_ifthenelse prfax
R13475:13490 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_ifthenelse prfax
R13508:13525 VST.floyd.canon <> semax_post_flipped thm
R13536:13545 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_skip prfax
R13508:13525 VST.floyd.canon <> semax_post_flipped thm
R13536:13545 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_skip prfax
R13812:13827 VST.floyd.canon <> semax_pre_simple thm
R13840:13850 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_break prfax
R13812:13827 VST.floyd.canon <> semax_pre_simple thm
R13840:13850 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_break prfax
R13922:13934 VST.msl.seplog <> derives_trans meth
R13922:13934 VST.msl.seplog <> derives_trans meth
R13967:13975 VST.msl.log_normalize <> andp_comm thm
R13967:13975 VST.msl.log_normalize <> andp_comm thm
R13967:13975 VST.msl.log_normalize <> andp_comm thm
R14002:14011 VST.msl.log_normalize <> andp_assoc thm
R14002:14011 VST.msl.log_normalize <> andp_assoc thm
R14002:14011 VST.msl.log_normalize <> andp_assoc thm
R14029:14044 VST.floyd.canon <> semax_pre_simple thm
R14029:14044 VST.floyd.canon <> semax_pre_simple thm
R14068:14077 VST.msl.seplog <> andp_left2 meth
R14068:14077 VST.msl.seplog <> andp_left2 meth
R14086:14095 VST.msl.seplog <> andp_left2 meth
R14086:14095 VST.msl.seplog <> andp_left2 meth
R14106:14114 VST.msl.log_normalize <> andp_comm thm
R14106:14114 VST.msl.log_normalize <> andp_comm thm
R14106:14114 VST.msl.log_normalize <> andp_comm thm
R14132:14149 VST.floyd.canon <> semax_post_flipped thm
R14132:14149 VST.floyd.canon <> semax_post_flipped thm
R14168:14177 VST.msl.seplog <> andp_left2 meth
R14168:14177 VST.msl.seplog <> andp_left2 meth
R14242:14251 VST.msl.seplog <> andp_left2 meth
R14242:14251 VST.msl.seplog <> andp_left2 meth
R14327:14336 VST.msl.seplog <> andp_left2 meth
R14327:14336 VST.msl.seplog <> andp_left2 meth
R14408:14417 VST.msl.seplog <> andp_left2 meth
R14408:14417 VST.msl.seplog <> andp_left2 meth
prf 14499:14507 <> semax_for
binder 14519:14523 <> Espec:133
R14530:14538 VST.veric.mpred <> compspecs class
binder 14526:14527 <> cs:134
binder 14542:14542 <> A:135
R14555:14558 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R14559:14561 compcert.common.Values <> val ind
R14554:14554 VST.floyd.forward_lemmas <> A:135 var
binder 14551:14551 <> v:136
binder 14564:14568 <> Delta:137
binder 14570:14570 <> P:138
binder 14572:14572 <> Q:139
binder 14574:14574 <> R:140
binder 14576:14579 <> test:141
binder 14581:14584 <> body:142
binder 14586:14589 <> incr:143
binder 14591:14597 <> PreIncr:144
binder 14599:14602 <> Post:145
R14640:14648 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R14649:14649 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R14775:14784 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R14785:14785 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R14893:14902 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R14903:14903 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R15075:15084 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R15085:15085 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R15196:15205 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R15206:15206 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R15336:15345 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R15347:15351 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R15494:15497 VST.floyd.forward_lemmas <> Post:145 var
R15426:15430 compcert.cfrontend.Clight <> Sloop constr
R15481:15484 VST.floyd.forward_lemmas <> incr:143 var
R15433:15441 compcert.cfrontend.Clight <> Ssequence constr
R15475:15478 VST.floyd.forward_lemmas <> body:142 var
R15444:15454 compcert.cfrontend.Clight <> Sifthenelse constr
R15467:15472 compcert.cfrontend.Clight <> Sbreak constr
R15461:15465 compcert.cfrontend.Clight <> Sskip constr
R15456:15459 VST.floyd.forward_lemmas <> test:141 var
R15369:15371 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R15375:15376 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R15374:15374 VST.floyd.forward_lemmas <> A:135 var
binder 15372:15372 <> a:146
R15377:15381 VST.floyd.canon <> PROPx def
R15390:15395 VST.floyd.canon <> LOCALx def
R15404:15407 VST.floyd.canon <> SEPx def
R15410:15410 VST.floyd.forward_lemmas <> R:140 var
R15412:15412 VST.floyd.forward_lemmas <> a:146 var
R15398:15398 VST.floyd.forward_lemmas <> Q:139 var
R15400:15400 VST.floyd.forward_lemmas <> a:146 var
R15384:15384 VST.floyd.forward_lemmas <> P:138 var
R15386:15386 VST.floyd.forward_lemmas <> a:146 var
R15362:15366 VST.floyd.forward_lemmas <> Delta:137 var
R15356:15360 VST.floyd.forward_lemmas <> Espec:133 var
R15353:15354 VST.floyd.forward_lemmas <> cs:134 var
R15216:15216 VST.floyd.forward_lemmas <> A:135 var
binder 15214:15214 <> a:147
R15219:15225 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R15231:15232 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R15307:15321 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R15226:15230 VST.floyd.forward_lemmas <> Delta:137 var
R15233:15237 VST.floyd.canon <> PROPx def
R15281:15286 VST.floyd.canon <> LOCALx def
R15295:15298 VST.floyd.canon <> SEPx def
R15301:15301 VST.floyd.forward_lemmas <> R:140 var
R15303:15303 VST.floyd.forward_lemmas <> a:147 var
R15289:15289 VST.floyd.forward_lemmas <> Q:139 var
R15291:15291 VST.floyd.forward_lemmas <> a:147 var
R15271:15274 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R15240:15250 VST.veric.SeparationLogic <> typed_false def
R15267:15267 VST.floyd.forward_lemmas <> v:136 var
R15269:15269 VST.floyd.forward_lemmas <> a:147 var
R15253:15258 compcert.cfrontend.Clight <> typeof def
R15260:15263 VST.floyd.forward_lemmas <> test:141 var
R15275:15275 VST.floyd.forward_lemmas <> P:138 var
R15277:15277 VST.floyd.forward_lemmas <> a:147 var
R15322:15330 VST.veric.tycontext <> RA_normal proj
R15332:15335 VST.floyd.forward_lemmas <> Post:145 var
binder 15093:15093 <> a:148
R15097:15101 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R15136:15152 VST.veric.SeparationLogic <> normal_ret_assert def
R15155:15159 VST.floyd.canon <> PROPx def
R15168:15173 VST.floyd.canon <> LOCALx def
R15182:15185 VST.floyd.canon <> SEPx def
R15188:15188 VST.floyd.forward_lemmas <> R:140 var
R15190:15190 VST.floyd.forward_lemmas <> a:148 var
R15176:15176 VST.floyd.forward_lemmas <> Q:139 var
R15178:15178 VST.floyd.forward_lemmas <> a:148 var
R15162:15162 VST.floyd.forward_lemmas <> P:138 var
R15164:15164 VST.floyd.forward_lemmas <> a:148 var
R15130:15133 VST.floyd.forward_lemmas <> incr:143 var
R15119:15125 VST.floyd.forward_lemmas <> PreIncr:144 var
R15127:15127 VST.floyd.forward_lemmas <> a:148 var
R15112:15116 VST.floyd.forward_lemmas <> Delta:137 var
R15106:15110 VST.floyd.forward_lemmas <> Espec:133 var
R15103:15104 VST.floyd.forward_lemmas <> cs:134 var
R14913:14913 VST.floyd.forward_lemmas <> A:135 var
binder 14911:14911 <> a:149
R14925:14929 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R15041:15056 VST.veric.SeparationLogic <> loop1_ret_assert def
R15070:15073 VST.floyd.forward_lemmas <> Post:145 var
R15059:15065 VST.floyd.forward_lemmas <> PreIncr:144 var
R15067:15067 VST.floyd.forward_lemmas <> a:149 var
R15035:15038 VST.floyd.forward_lemmas <> body:142 var
R14947:14951 VST.floyd.canon <> PROPx def
R14994:14999 VST.floyd.canon <> LOCALx def
R15008:15011 VST.floyd.canon <> SEPx def
R15014:15014 VST.floyd.forward_lemmas <> R:140 var
R15016:15016 VST.floyd.forward_lemmas <> a:149 var
R15002:15002 VST.floyd.forward_lemmas <> Q:139 var
R15004:15004 VST.floyd.forward_lemmas <> a:149 var
R14984:14987 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R14954:14963 VST.veric.SeparationLogic <> typed_true def
R14980:14980 VST.floyd.forward_lemmas <> v:136 var
R14982:14982 VST.floyd.forward_lemmas <> a:149 var
R14966:14971 compcert.cfrontend.Clight <> typeof def
R14973:14976 VST.floyd.forward_lemmas <> test:141 var
R14988:14988 VST.floyd.forward_lemmas <> P:138 var
R14990:14990 VST.floyd.forward_lemmas <> a:149 var
R14940:14944 VST.floyd.forward_lemmas <> Delta:137 var
R14934:14938 VST.floyd.forward_lemmas <> Espec:133 var
R14931:14932 VST.floyd.forward_lemmas <> cs:134 var
R14795:14795 VST.floyd.forward_lemmas <> A:135 var
binder 14793:14793 <> a:150
R14798:14804 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R14810:14811 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R14851:14856 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R14805:14809 VST.floyd.forward_lemmas <> Delta:137 var
R14812:14816 VST.floyd.canon <> PROPx def
R14825:14830 VST.floyd.canon <> LOCALx def
R14839:14842 VST.floyd.canon <> SEPx def
R14845:14845 VST.floyd.forward_lemmas <> R:140 var
R14847:14847 VST.floyd.forward_lemmas <> a:150 var
R14833:14833 VST.floyd.forward_lemmas <> Q:139 var
R14835:14835 VST.floyd.forward_lemmas <> a:150 var
R14819:14819 VST.floyd.forward_lemmas <> P:138 var
R14821:14821 VST.floyd.forward_lemmas <> a:150 var
R14857:14861 VST.veric.SeparationLogic <> local def
R14864:14865 VST.veric.lift LiftNotation :::'`('_x_')' not
R14874:14891 VST.veric.lift LiftNotation :::'`('_x_')' not
R14866:14867 Coq.Init.Logic <> eq ind
R14870:14870 VST.floyd.forward_lemmas <> v:136 var
R14872:14872 VST.floyd.forward_lemmas <> a:150 var
R14877:14885 VST.veric.expr <> eval_expr def
R14887:14890 VST.floyd.forward_lemmas <> test:141 var
R14659:14659 VST.floyd.forward_lemmas <> A:135 var
binder 14657:14657 <> a:151
R14662:14668 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R14674:14675 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R14715:14730 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R14669:14673 VST.floyd.forward_lemmas <> Delta:137 var
R14676:14680 VST.floyd.canon <> PROPx def
R14689:14694 VST.floyd.canon <> LOCALx def
R14703:14706 VST.floyd.canon <> SEPx def
R14709:14709 VST.floyd.forward_lemmas <> R:140 var
R14711:14711 VST.floyd.forward_lemmas <> a:151 var
R14697:14697 VST.floyd.forward_lemmas <> Q:139 var
R14699:14699 VST.floyd.forward_lemmas <> a:151 var
R14683:14683 VST.floyd.forward_lemmas <> P:138 var
R14685:14685 VST.floyd.forward_lemmas <> a:151 var
R14731:14737 VST.veric.SeparationLogic <> tc_expr def
R14746:14750 compcert.cfrontend.Clight <> Eunop constr
R14770:14773 compcert.exportclight.Clightdefs <> tint def
R14765:14768 VST.floyd.forward_lemmas <> test:141 var
R14752:14763 compcert.cfrontend.Cop <> Onotbool constr
R14739:14743 VST.floyd.forward_lemmas <> Delta:137 var
R14633:14635 Coq.Init.Logic <> ::type_scope:x_'='_x not
R14610:14618 VST.veric.expr <> bool_type def
R14621:14626 compcert.cfrontend.Clight <> typeof def
R14628:14631 VST.floyd.forward_lemmas <> test:141 var
R14636:14639 Coq.Init.Datatypes <> true constr
R15539:15541 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R15545:15546 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
binder 15542:15542 <> a:152
R15555:15555 VST.floyd.forward_lemmas <> a:152 var
R15521:15531 VST.floyd.forward_lemmas <> semax_for_x thm
R15539:15541 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R15545:15546 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
binder 15542:15542 <> a:153
R15555:15555 VST.floyd.forward_lemmas <> a:153 var
R15521:15531 VST.floyd.forward_lemmas <> semax_for_x thm
R15594:15606 VST.msl.seplog <> derives_trans meth
R15594:15606 VST.msl.seplog <> derives_trans meth
R15650:15662 VST.msl.seplog <> derives_trans meth
R15676:15688 VST.msl.seplog <> derives_trans meth
R15700:15711 VST.msl.log_normalize <> andp_derives thm
R15650:15662 VST.msl.seplog <> derives_trans meth
R15676:15688 VST.msl.seplog <> derives_trans meth
R15700:15711 VST.msl.log_normalize <> andp_derives thm
R15725:15734 VST.msl.seplog <> andp_right meth
R15725:15734 VST.msl.seplog <> andp_right meth
R15746:15754 VST.msl.log_normalize <> andp_comm thm
R15757:15761 VST.veric.SeparationLogic <> local def
R15764:15773 VST.veric.SeparationLogic <> tc_environ def
R15746:15754 VST.msl.log_normalize <> andp_comm thm
R15757:15761 VST.veric.SeparationLogic <> local def
R15764:15773 VST.veric.SeparationLogic <> tc_environ def
R15746:15754 VST.msl.log_normalize <> andp_comm thm
R15757:15761 VST.veric.SeparationLogic <> local def
R15764:15773 VST.veric.SeparationLogic <> tc_environ def
R15789:15798 VST.msl.log_normalize <> andp_assoc thm
R15789:15798 VST.msl.log_normalize <> andp_assoc thm
R15789:15798 VST.msl.log_normalize <> andp_assoc thm
R15807:15816 VST.msl.seplog <> andp_left2 meth
R15807:15816 VST.msl.seplog <> andp_left2 meth
R15835:15846 VST.msl.seplog <> derives_refl meth
R15835:15846 VST.msl.seplog <> derives_refl meth
R15855:15866 VST.msl.seplog <> derives_refl meth
R15855:15866 VST.msl.seplog <> derives_refl meth
R15875:15886 VST.msl.seplog <> derives_refl meth
R15875:15886 VST.msl.seplog <> derives_refl meth
R15900:15910 VST.floyd.canon <> insert_prop thm
R15900:15910 VST.floyd.canon <> insert_prop thm
R15900:15910 VST.floyd.canon <> insert_prop thm
R15925:15934 VST.msl.log_normalize <> andp_assoc thm
R15925:15934 VST.msl.log_normalize <> andp_assoc thm
R15925:15934 VST.msl.log_normalize <> andp_assoc thm
R15925:15934 VST.msl.log_normalize <> andp_assoc thm
R15925:15934 VST.msl.log_normalize <> andp_assoc thm
R15925:15934 VST.msl.log_normalize <> andp_assoc thm
R15943:15954 VST.msl.log_normalize <> andp_derives thm
R15943:15954 VST.msl.log_normalize <> andp_derives thm
R15981:15985 VST.veric.SeparationLogic <> local def
R15988:15992 VST.veric.mpred <> lift1 def
R16074:16091 VST.floyd.base <> extract_exists_pre def
R16074:16091 VST.floyd.base <> extract_exists_pre def
R16110:16123 VST.floyd.canon <> semax_pre_post thm
R16110:16123 VST.floyd.canon <> semax_pre_post thm
R16155:16165 VST.floyd.canon <> insert_prop thm
R16155:16165 VST.floyd.canon <> insert_prop thm
R16155:16165 VST.floyd.canon <> insert_prop thm
R16175:16187 VST.msl.seplog <> derives_trans meth
R16201:16213 VST.msl.seplog <> derives_trans meth
R16175:16187 VST.msl.seplog <> derives_trans meth
R16201:16213 VST.msl.seplog <> derives_trans meth
R16224:16233 VST.msl.seplog <> andp_right meth
R16246:16257 VST.msl.seplog <> derives_refl meth
R16224:16233 VST.msl.seplog <> andp_right meth
R16246:16257 VST.msl.seplog <> derives_refl meth
R16268:16280 VST.msl.seplog <> derives_trans meth
R16268:16280 VST.msl.seplog <> derives_trans meth
R16308:16319 VST.msl.log_normalize <> andp_derives thm
R16308:16319 VST.msl.log_normalize <> andp_derives thm
R16334:16343 VST.msl.seplog <> andp_left2 meth
R16334:16343 VST.msl.seplog <> andp_left2 meth
R16358:16369 VST.msl.seplog <> derives_refl meth
R16358:16369 VST.msl.seplog <> derives_refl meth
R16384:16393 VST.msl.log_normalize <> andp_assoc thm
R16384:16393 VST.msl.log_normalize <> andp_assoc thm
R16384:16393 VST.msl.log_normalize <> andp_assoc thm
R16384:16393 VST.msl.log_normalize <> andp_assoc thm
R16384:16393 VST.msl.log_normalize <> andp_assoc thm
R16402:16413 VST.msl.log_normalize <> andp_derives thm
R16402:16413 VST.msl.log_normalize <> andp_derives thm
R16440:16444 VST.veric.SeparationLogic <> local def
R16447:16451 VST.veric.mpred <> lift1 def
R16517:16526 VST.msl.seplog <> andp_left2 meth
R16517:16526 VST.msl.seplog <> andp_left2 meth
R16536:16551 VST.veric.SeparationLogic <> loop1_ret_assert def
R16592:16600 VST.msl.seplog <> exp_right meth
R16616:16627 VST.msl.seplog <> derives_refl meth
R16592:16600 VST.msl.seplog <> exp_right meth
R16616:16627 VST.msl.seplog <> derives_refl meth
R16668:16677 VST.msl.seplog <> andp_left2 meth
R16686:16697 VST.msl.seplog <> derives_refl meth
R16668:16677 VST.msl.seplog <> andp_left2 meth
R16686:16697 VST.msl.seplog <> derives_refl meth
R16738:16746 VST.msl.seplog <> exp_right meth
R16762:16771 VST.msl.seplog <> andp_left2 meth
R16738:16746 VST.msl.seplog <> exp_right meth
R16762:16771 VST.msl.seplog <> andp_left2 meth
R16836:16845 VST.msl.seplog <> andp_left2 meth
R16854:16865 VST.msl.seplog <> derives_refl meth
R16836:16845 VST.msl.seplog <> andp_left2 meth
R16854:16865 VST.msl.seplog <> derives_refl meth
R16874:16891 VST.floyd.base <> extract_exists_pre def
R16874:16891 VST.floyd.base <> extract_exists_pre def
R16910:16920 VST.floyd.canon <> semax_post' thm
R16910:16920 VST.floyd.canon <> semax_post' thm
R16947:16955 VST.msl.seplog <> exp_right meth
R16947:16955 VST.msl.seplog <> exp_right meth
R16977:16986 VST.msl.seplog <> andp_left2 meth
R16977:16986 VST.msl.seplog <> andp_left2 meth
prf 18028:18040 <> forward_setx'
binder 18052:18056 <> Espec:154
R18063:18071 VST.veric.mpred <> compspecs class
binder 18059:18060 <> cs:155
binder 18074:18078 <> Delta:156
binder 18080:18080 <> P:157
binder 18082:18083 <> id:158
binder 18085:18085 <> e:159
R18090:18090 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R18152:18159 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R18161:18165 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R18236:18252 VST.veric.SeparationLogic <> normal_ret_assert def
R18273:18275 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R18283:18285 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R18280:18282 compcert.common.Values <> val ind
binder 18276:18278 <> old:160
R18342:18373 VST.msl.seplog <> ::logic:x_'&&'_x not
R18286:18290 VST.veric.SeparationLogic <> local def
R18293:18293 VST.veric.lift LiftNotation :::'`'_x not
R18296:18340 VST.veric.lift LiftNotation :::'`'_x not
R18294:18295 Coq.Init.Logic <> eq ind
R18311:18315 VST.veric.seplog <> subst def
R18328:18336 VST.veric.expr <> eval_expr def
R18338:18338 VST.floyd.forward_lemmas <> e:159 var
R18321:18321 VST.veric.lift LiftNotation :::'`'_x not
R18322:18324 VST.floyd.forward_lemmas <> old:160 var
R18317:18318 VST.floyd.forward_lemmas <> id:158 var
R18298:18304 VST.veric.mpred <> eval_id def
R18306:18307 VST.floyd.forward_lemmas <> id:158 var
R18374:18378 VST.veric.seplog <> subst def
R18390:18390 VST.floyd.forward_lemmas <> P:157 var
R18384:18384 VST.veric.lift LiftNotation :::'`'_x not
R18385:18387 VST.floyd.forward_lemmas <> old:160 var
R18380:18381 VST.floyd.forward_lemmas <> id:158 var
R18211:18214 compcert.cfrontend.Clight <> Sset constr
R18219:18219 VST.floyd.forward_lemmas <> e:159 var
R18216:18217 VST.floyd.forward_lemmas <> id:158 var
R18195:18195 VST.floyd.forward_lemmas <> P:157 var
R18176:18180 VST.floyd.forward_lemmas <> Delta:156 var
R18170:18174 VST.floyd.forward_lemmas <> Espec:154 var
R18167:18168 VST.floyd.forward_lemmas <> cs:155 var
R18092:18096 VST.msl.seplog <> ::logic_derives:x_'|--'_x not
R18091:18091 VST.floyd.forward_lemmas <> P:157 var
R18097:18097 VST.msl.seplog <> ::logic:x_'&&'_x not
R18113:18118 VST.msl.seplog <> ::logic:x_'&&'_x not
R18151:18151 VST.msl.seplog <> ::logic:x_'&&'_x not
R18098:18104 VST.veric.SeparationLogic <> tc_expr def
R18112:18112 VST.floyd.forward_lemmas <> e:159 var
R18106:18110 VST.floyd.forward_lemmas <> Delta:156 var
R18119:18128 VST.veric.SeparationLogic <> tc_temp_id def
R18150:18150 VST.floyd.forward_lemmas <> e:159 var
R18144:18148 VST.floyd.forward_lemmas <> Delta:156 var
R18134:18139 compcert.cfrontend.Clight <> typeof def
R18141:18141 VST.floyd.forward_lemmas <> e:159 var
R18130:18131 VST.floyd.forward_lemmas <> id:158 var
R18417:18425 VST.floyd.canon <> semax_pre thm
R18439:18455 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_set_forward prfax
R18417:18425 VST.floyd.canon <> semax_pre thm
R18439:18455 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_set_forward prfax
R18439:18455 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_set_forward prfax
R18481:18493 VST.msl.seplog <> derives_trans meth
R18507:18515 VST.msl.seplog <> now_later meth
R18481:18493 VST.msl.seplog <> derives_trans meth
R18507:18515 VST.msl.seplog <> now_later meth
R18528:18537 VST.msl.seplog <> andp_left2 meth
R18546:18555 VST.msl.seplog <> andp_right meth
R18528:18537 VST.msl.seplog <> andp_left2 meth
R18546:18555 VST.msl.seplog <> andp_right meth
prf 19951:19966 <> semax_switch_PQR
R19987:19996 VST.veric.juicy_extspec <> OracleKind class
binder 19980:19984 <> Espec:161
R20003:20011 VST.veric.mpred <> compspecs class
binder 19999:20000 <> CS:162
binder 20025:20025 <> n:163
binder 20027:20031 <> Delta:164
R20046:20047 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R20048:20052 VST.veric.mpred <> mpred def
R20039:20045 VST.veric.mpred <> environ ind
binder 20034:20036 <> Pre:165
binder 20055:20055 <> a:166
binder 20057:20058 <> sl:167
R20067:20076 VST.veric.tycontext <> ret_assert rec
binder 20061:20064 <> Post:168
R20114:20122 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R20160:20168 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R20238:20246 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R20417:20425 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R20427:20431 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R20467:20470 VST.floyd.forward_lemmas <> Post:168 var
R20453:20459 compcert.cfrontend.Clight <> Sswitch constr
R20463:20464 VST.floyd.forward_lemmas <> sl:167 var
R20461:20461 VST.floyd.forward_lemmas <> a:166 var
R20448:20450 VST.floyd.forward_lemmas <> Pre:165 var
R20442:20446 VST.floyd.forward_lemmas <> Delta:164 var
R20436:20440 VST.floyd.forward_lemmas <> Espec:161 var
R20433:20434 VST.floyd.forward_lemmas <> CS:162 var
R20248:20252 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R20394:20410 VST.veric.SeparationLogic <> switch_ret_assert def
R20412:20415 VST.floyd.forward_lemmas <> Post:168 var
R20305:20328 compcert.cfrontend.Clight <> seq_of_labeled_statement def
R20331:20343 compcert.cfrontend.Clight <> select_switch def
R20373:20374 VST.floyd.forward_lemmas <> sl:167 var
R20346:20357 compcert.lib.Integers Int unsigned def
R20360:20367 compcert.lib.Integers Int repr def
R20369:20369 VST.floyd.forward_lemmas <> n:163 var
R20285:20287 VST.floyd.forward_lemmas <> Pre:165 var
R20263:20267 VST.floyd.forward_lemmas <> Delta:164 var
R20257:20261 VST.floyd.forward_lemmas <> Espec:161 var
R20254:20255 VST.floyd.forward_lemmas <> CS:162 var
R20169:20175 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R20181:20182 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R20186:20190 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R20176:20180 VST.floyd.forward_lemmas <> Delta:164 var
R20183:20185 VST.floyd.forward_lemmas <> Pre:165 var
R20191:20195 VST.veric.SeparationLogic <> local def
R20198:20199 VST.veric.lift LiftNotation :::'`('_x_')' not
R20222:20236 VST.veric.lift LiftNotation :::'`('_x_')' not
R20200:20201 Coq.Init.Logic <> eq ind
R20204:20207 compcert.common.Values <> Vint constr
R20210:20217 compcert.lib.Integers Int repr def
R20219:20219 VST.floyd.forward_lemmas <> n:163 var
R20225:20233 VST.veric.expr <> eval_expr def
R20235:20235 VST.floyd.forward_lemmas <> a:166 var
R20123:20129 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R20135:20136 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R20140:20144 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R20130:20134 VST.floyd.forward_lemmas <> Delta:164 var
R20137:20139 VST.floyd.forward_lemmas <> Pre:165 var
R20145:20151 VST.veric.SeparationLogic <> tc_expr def
R20159:20159 VST.floyd.forward_lemmas <> a:166 var
R20153:20157 VST.floyd.forward_lemmas <> Delta:164 var
R20107:20109 Coq.Init.Logic <> ::type_scope:x_'='_x not
R20085:20095 VST.veric.expr <> is_int_type def
R20098:20103 compcert.cfrontend.Clight <> typeof def
R20105:20105 VST.floyd.forward_lemmas <> a:166 var
R20110:20113 Coq.Init.Datatypes <> true constr
R20495:20503 VST.floyd.canon <> semax_pre thm
R20495:20503 VST.floyd.canon <> semax_pre thm
R20512:20523 VST.msl.seplog <> derives_refl meth
R20512:20523 VST.msl.seplog <> derives_refl meth
R20533:20544 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_switch prfax
R20533:20544 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_switch prfax
R20579:20581 Coq.Init.Logic <> ::type_scope:x_'='_x not
R20582:20589 compcert.lib.Integers Int repr def
R20579:20581 Coq.Init.Logic <> ::type_scope:x_'='_x not
R20582:20589 compcert.lib.Integers Int repr def
R20671:20674 VST.msl.seplog <> ::logic:x_'&&'_x not
R20623:20627 VST.veric.SeparationLogic <> local def
R20630:20632 VST.veric.lift LiftNotation :::'`('_x_')' not
R20655:20669 VST.veric.lift LiftNotation :::'`('_x_')' not
R20633:20634 Coq.Init.Logic <> eq ind
R20637:20640 compcert.common.Values <> Vint constr
R20643:20650 compcert.lib.Integers Int repr def
R20658:20666 VST.veric.expr <> eval_expr def
R20675:20679 VST.veric.SeparationLogic <> local def
R20682:20683 VST.veric.lift LiftNotation :::'`'_x not
R20686:20710 VST.veric.lift LiftNotation :::'`'_x not
R20684:20685 Coq.Init.Logic <> eq ind
R20701:20702 VST.veric.lift LiftNotation :::'`('_x_')' not
R20710:20710 VST.veric.lift LiftNotation :::'`('_x_')' not
R20703:20706 compcert.common.Values <> Vint constr
R20688:20696 VST.veric.expr <> eval_expr def
R20603:20615 VST.msl.seplog <> derives_trans meth
R20671:20674 VST.msl.seplog <> ::logic:x_'&&'_x not
R20623:20627 VST.veric.SeparationLogic <> local def
R20630:20632 VST.veric.lift LiftNotation :::'`('_x_')' not
R20655:20669 VST.veric.lift LiftNotation :::'`('_x_')' not
R20633:20634 Coq.Init.Logic <> eq ind
R20637:20640 compcert.common.Values <> Vint constr
R20643:20650 compcert.lib.Integers Int repr def
R20658:20666 VST.veric.expr <> eval_expr def
R20675:20679 VST.veric.SeparationLogic <> local def
R20682:20683 VST.veric.lift LiftNotation :::'`'_x not
R20686:20710 VST.veric.lift LiftNotation :::'`'_x not
R20684:20685 Coq.Init.Logic <> eq ind
R20701:20702 VST.veric.lift LiftNotation :::'`('_x_')' not
R20710:20710 VST.veric.lift LiftNotation :::'`('_x_')' not
R20703:20706 compcert.common.Values <> Vint constr
R20688:20696 VST.veric.expr <> eval_expr def
R20603:20615 VST.msl.seplog <> derives_trans meth
R20721:20730 VST.msl.seplog <> andp_right meth
R20721:20730 VST.msl.seplog <> andp_right meth
R20740:20752 VST.msl.seplog <> derives_trans meth
R20740:20752 VST.msl.seplog <> derives_trans meth
R20791:20795 VST.veric.SeparationLogic <> local def
R20798:20802 VST.veric.mpred <> lift1 def
R20805:20809 VST.veric.lift <> liftx def
R20812:20815 VST.veric.lift <> lift def
R20854:20858 VST.veric.SeparationLogic <> local def
R20861:20865 VST.veric.mpred <> lift1 def
R20868:20872 VST.veric.lift <> liftx def
R20875:20878 VST.veric.lift <> lift def
R20917:20921 VST.veric.SeparationLogic <> local def
R20924:20928 VST.veric.mpred <> lift1 def
R20931:20935 VST.veric.lift <> liftx def
R20938:20941 VST.veric.lift <> lift def
R20989:20996 VST.veric.base <> Vint_inj thm
R20989:20996 VST.veric.base <> Vint_inj thm
R21030:21038 VST.floyd.canon <> semax_pre thm
R21030:21038 VST.floyd.canon <> semax_pre thm
R21065:21074 VST.msl.seplog <> andp_left2 meth
R21065:21074 VST.msl.seplog <> andp_left2 meth
R21083:21092 VST.msl.seplog <> andp_left2 meth
R21083:21092 VST.msl.seplog <> andp_left2 meth
R21101:21110 VST.msl.seplog <> andp_left2 meth
R21101:21110 VST.msl.seplog <> andp_left2 meth
prf 21131:21145 <> modulo_samerepr
binder 21156:21156 <> x:169
binder 21158:21158 <> y:170
R21211:21217 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R21228:21230 Coq.Init.Logic <> ::type_scope:x_'='_x not
R21218:21225 compcert.lib.Integers Int repr def
R21227:21227 VST.floyd.forward_lemmas <> x:169 var
R21231:21238 compcert.lib.Integers Int repr def
R21240:21240 VST.floyd.forward_lemmas <> y:170 var
R21186:21188 Coq.Init.Logic <> ::type_scope:x_'='_x not
R21164:21171 Coq.ZArith.BinInt Z modulo def
R21175:21185 compcert.lib.Integers Int modulus def
R21173:21173 VST.floyd.forward_lemmas <> x:169 var
R21189:21196 Coq.ZArith.BinInt Z modulo def
R21200:21210 compcert.lib.Integers Int modulus def
R21198:21198 VST.floyd.forward_lemmas <> y:170 var
R21264:21279 compcert.lib.Integers Int eqm_samerepr thm
R21264:21279 compcert.lib.Integers Int eqm_samerepr thm
R21288:21304 Coq.ZArith.Znumtheory <> Zmod_divide_minus thm
R21288:21304 Coq.ZArith.Znumtheory <> Zmod_divide_minus thm
R21337:21343 compcert.lib.Integers Int eqm def
R21353:21363 compcert.lib.Zbits <> eqmod def
R21376:21386 compcert.lib.Integers Int modulus def
R21376:21386 compcert.lib.Integers Int modulus def
R21425:21427 Coq.Init.Logic <> ::type_scope:x_'='_x not
R21435:21437 Coq.ZArith.BinInt <> ::Z_scope:x_'+'_x not
R21429:21433 Coq.ZArith.BinInt <> ::Z_scope:x_'mod'_x not
R21439:21441 Coq.ZArith.BinInt <> ::Z_scope:x_'*'_x not
R21425:21427 Coq.Init.Logic <> ::type_scope:x_'='_x not
R21435:21437 Coq.ZArith.BinInt <> ::Z_scope:x_'+'_x not
R21429:21433 Coq.ZArith.BinInt <> ::Z_scope:x_'mod'_x not
R21439:21441 Coq.ZArith.BinInt <> ::Z_scope:x_'*'_x not
R21483:21491 Coq.ZArith.BinInt Z div_mod thm
R21483:21491 Coq.ZArith.BinInt Z div_mod thm
R21534:21534 Coq.Numbers.BinNums <> Z ind
R21534:21534 Coq.Numbers.BinNums <> Z ind
R21582:21591 Coq.ZArith.BinInt Z mul_comm thm
R21582:21591 Coq.ZArith.BinInt Z mul_comm thm
R21582:21591 Coq.ZArith.BinInt Z mul_comm thm
R21610:21612 Coq.Init.Logic <> ::type_scope:x_'='_x not
R21606:21608 Coq.ZArith.BinInt <> ::Z_scope:x_'*'_x not
R21616:21619 Coq.ZArith.BinInt <> ::Z_scope:x_'+'_x not
R21625:21625 Coq.ZArith.BinInt <> ::Z_scope:x_'+'_x not
R21614:21614 Coq.ZArith.BinInt <> ::Z_scope:x_'*'_x not
R21623:21623 Coq.ZArith.BinInt <> ::Z_scope:x_'*'_x not
R21621:21621 Coq.ZArith.BinInt <> ::Z_scope:x_'/'_x not
R21610:21612 Coq.Init.Logic <> ::type_scope:x_'='_x not
R21606:21608 Coq.ZArith.BinInt <> ::Z_scope:x_'*'_x not
R21616:21619 Coq.ZArith.BinInt <> ::Z_scope:x_'+'_x not
R21625:21625 Coq.ZArith.BinInt <> ::Z_scope:x_'+'_x not
R21614:21614 Coq.ZArith.BinInt <> ::Z_scope:x_'*'_x not
R21623:21623 Coq.ZArith.BinInt <> ::Z_scope:x_'*'_x not
R21621:21621 Coq.ZArith.BinInt <> ::Z_scope:x_'/'_x not
R21652:21668 Coq.ZArith.BinInt Z mul_add_distr_r thm
R21652:21668 Coq.ZArith.BinInt Z mul_add_distr_r thm
R21652:21668 Coq.ZArith.BinInt Z mul_add_distr_r thm
R21689:21691 Coq.Init.Logic <> ::type_scope:x_'='_x not
R21693:21695 Coq.ZArith.BinInt <> ::Z_scope:x_'-'_x not
R21697:21697 Coq.ZArith.BinInt <> ::Z_scope:x_'/'_x not
R21689:21691 Coq.Init.Logic <> ::type_scope:x_'='_x not
R21693:21695 Coq.ZArith.BinInt <> ::Z_scope:x_'-'_x not
R21697:21697 Coq.ZArith.BinInt <> ::Z_scope:x_'/'_x not
prf 21746:21770 <> select_switch_case_signed
binder 21781:21781 <> y:171
binder 21783:21783 <> n:172
binder 21785:21785 <> x:173
binder 21787:21787 <> c:174
binder 21789:21790 <> sl:175
R21841:21845 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R21866:21870 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R21914:21918 Coq.Init.Logic <> ::type_scope:x_'='_x not
R21871:21888 compcert.cfrontend.Clight <> select_switch_case def
R21893:21898 compcert.cfrontend.Clight <> LScons constr
R21911:21912 VST.floyd.forward_lemmas <> sl:175 var
R21909:21909 VST.floyd.forward_lemmas <> c:174 var
R21901:21904 Coq.Init.Datatypes <> Some constr
R21906:21906 VST.floyd.forward_lemmas <> x:173 var
R21890:21890 VST.floyd.forward_lemmas <> n:172 var
R21922:21924 compcert.lib.Coqlib <> zeq def
R21954:21954 VST.floyd.forward_lemmas <> n:172 var
R21927:21938 compcert.lib.Integers Int unsigned def
R21941:21948 compcert.lib.Integers Int repr def
R21950:21950 VST.floyd.forward_lemmas <> y:171 var
R21995:22012 compcert.cfrontend.Clight <> select_switch_case def
R22016:22017 VST.floyd.forward_lemmas <> sl:175 var
R22014:22014 VST.floyd.forward_lemmas <> n:172 var
R21961:21964 Coq.Init.Datatypes <> Some constr
R21967:21972 compcert.cfrontend.Clight <> LScons constr
R21985:21986 VST.floyd.forward_lemmas <> sl:175 var
R21983:21983 VST.floyd.forward_lemmas <> c:174 var
R21975:21978 Coq.Init.Datatypes <> Some constr
R21980:21980 VST.floyd.forward_lemmas <> x:173 var
R21847:21850 Coq.ZArith.BinInt <> ::Z_scope:x_'<='_x_'<'_x not
R21852:21854 Coq.ZArith.BinInt <> ::Z_scope:x_'<='_x_'<'_x not
R21851:21851 VST.floyd.forward_lemmas <> x:173 var
R21851:21851 VST.floyd.forward_lemmas <> x:173 var
R21855:21865 compcert.lib.Integers Int modulus def
R21816:21818 Coq.Init.Logic <> ::type_scope:x_'='_x not
R21794:21801 Coq.ZArith.BinInt Z modulo def
R21805:21815 compcert.lib.Integers Int modulus def
R21803:21803 VST.floyd.forward_lemmas <> x:173 var
R21819:21826 Coq.ZArith.BinInt Z modulo def
R21830:21840 compcert.lib.Integers Int modulus def
R21828:21828 VST.floyd.forward_lemmas <> y:171 var
R22048:22062 VST.floyd.forward_lemmas <> modulo_samerepr thm
R22048:22062 VST.floyd.forward_lemmas <> modulo_samerepr thm
R22092:22108 compcert.lib.Integers Int unsigned_repr thm
R22092:22108 compcert.lib.Integers Int unsigned_repr thm
R22092:22108 compcert.lib.Integers Int unsigned_repr thm
def 22145:22150 <> signof
R22156:22159 compcert.cfrontend.Clight <> expr ind
binder 22153:22153 <> e:176
R22174:22179 compcert.cfrontend.Clight <> typeof def
R22181:22181 VST.floyd.forward_lemmas <> e:176 var
R22192:22195 compcert.cfrontend.Ctypes <> Tint constr
R22212:22216 compcert.cfrontend.Ctypes <> Tlong constr
R22238:22245 compcert.cfrontend.Ctypes <> Unsigned constr
def 22266:22280 <> adjust_for_sign
R22286:22295 compcert.cfrontend.Ctypes <> signedness ind
binder 22283:22283 <> s:177
R22302:22302 Coq.Numbers.BinNums <> Z ind
binder 22299:22299 <> x:178
R22315:22315 VST.floyd.forward_lemmas <> s:177 var
R22325:22332 compcert.cfrontend.Ctypes <> Unsigned constr
R22337:22337 VST.floyd.forward_lemmas <> x:178 var
R22343:22348 compcert.cfrontend.Ctypes <> Signed constr
R22357:22359 compcert.lib.Coqlib <> zlt def
R22363:22378 compcert.lib.Integers Int half_modulus def
R22361:22361 VST.floyd.forward_lemmas <> x:178 var
R22394:22396 Coq.ZArith.BinInt <> ::Z_scope:x_'-'_x not
R22393:22393 VST.floyd.forward_lemmas <> x:178 var
R22397:22407 compcert.lib.Integers Int modulus def
R22386:22386 VST.floyd.forward_lemmas <> x:178 var
prf 23367:23379 <> semax_for_3g1
binder 23391:23395 <> Espec:180
R23402:23410 VST.veric.mpred <> compspecs class
binder 23398:23399 <> cs:181
binder 23414:23414 <> A:182
R23424:23427 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R23435:23438 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R23439:23443 VST.veric.mpred <> mpred def
R23428:23434 VST.veric.mpred <> environ ind
R23423:23423 VST.floyd.forward_lemmas <> A:182 var
binder 23418:23420 <> PQR:183
R23451:23454 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R23455:23457 compcert.common.Values <> val ind
R23450:23450 VST.floyd.forward_lemmas <> A:182 var
binder 23447:23447 <> v:184
binder 23460:23464 <> Delta:185
binder 23466:23466 <> P:186
binder 23468:23468 <> Q:187
binder 23470:23470 <> R:188
binder 23472:23475 <> test:189
binder 23477:23480 <> body:190
binder 23482:23485 <> incr:191
binder 23487:23490 <> Post:192
R23528:23536 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R23537:23537 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R23652:23661 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R23662:23662 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R23767:23776 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R23777:23777 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R23949:23958 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R23959:23959 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R24099:24108 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R24109:24109 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R24259:24268 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R24270:24274 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R24438:24441 VST.floyd.forward_lemmas <> Post:192 var
R24359:24363 compcert.cfrontend.Clight <> Sloop constr
R24415:24418 VST.floyd.forward_lemmas <> incr:191 var
R24366:24374 compcert.cfrontend.Clight <> Ssequence constr
R24409:24412 VST.floyd.forward_lemmas <> body:190 var
R24377:24387 compcert.cfrontend.Clight <> Sifthenelse constr
R24400:24405 compcert.cfrontend.Clight <> Sbreak constr
R24394:24398 compcert.cfrontend.Clight <> Sskip constr
R24389:24392 VST.floyd.forward_lemmas <> test:189 var
R24292:24294 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R24298:24299 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R24297:24297 VST.floyd.forward_lemmas <> A:182 var
binder 24295:24295 <> a:193
R24300:24304 VST.floyd.canon <> PROPx def
R24313:24318 VST.floyd.canon <> LOCALx def
R24327:24330 VST.floyd.canon <> SEPx def
R24333:24333 VST.floyd.forward_lemmas <> R:188 var
R24335:24335 VST.floyd.forward_lemmas <> a:193 var
R24321:24321 VST.floyd.forward_lemmas <> Q:187 var
R24323:24323 VST.floyd.forward_lemmas <> a:193 var
R24307:24307 VST.floyd.forward_lemmas <> P:186 var
R24309:24309 VST.floyd.forward_lemmas <> a:193 var
R24285:24289 VST.floyd.forward_lemmas <> Delta:185 var
R24279:24283 VST.floyd.forward_lemmas <> Espec:180 var
R24276:24277 VST.floyd.forward_lemmas <> cs:181 var
binder 24117:24117 <> a:194
R24120:24126 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R24132:24133 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R24210:24244 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R24127:24131 VST.floyd.forward_lemmas <> Delta:185 var
R24134:24138 VST.floyd.canon <> PROPx def
R24184:24189 VST.floyd.canon <> LOCALx def
R24198:24201 VST.floyd.canon <> SEPx def
R24204:24204 VST.floyd.forward_lemmas <> R:188 var
R24206:24206 VST.floyd.forward_lemmas <> a:194 var
R24192:24192 VST.floyd.forward_lemmas <> Q:187 var
R24194:24194 VST.floyd.forward_lemmas <> a:194 var
R24172:24176 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R24180:24180 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R24141:24151 VST.veric.SeparationLogic <> typed_false def
R24168:24168 VST.floyd.forward_lemmas <> v:184 var
R24170:24170 VST.floyd.forward_lemmas <> a:194 var
R24154:24159 compcert.cfrontend.Clight <> typeof def
R24161:24164 VST.floyd.forward_lemmas <> test:189 var
R24177:24177 VST.floyd.forward_lemmas <> P:186 var
R24179:24179 VST.floyd.forward_lemmas <> a:194 var
R24245:24253 VST.veric.tycontext <> RA_normal proj
R24255:24258 VST.floyd.forward_lemmas <> Post:192 var
binder 23967:23967 <> a:195
R23971:23975 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R24031:24047 VST.veric.SeparationLogic <> normal_ret_assert def
R24050:24052 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R24056:24057 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R24055:24055 VST.floyd.forward_lemmas <> A:182 var
binder 24053:24053 <> a:196
R24058:24062 VST.floyd.canon <> PROPx def
R24071:24076 VST.floyd.canon <> LOCALx def
R24085:24088 VST.floyd.canon <> SEPx def
R24091:24091 VST.floyd.forward_lemmas <> R:188 var
R24093:24093 VST.floyd.forward_lemmas <> a:196 var
R24079:24079 VST.floyd.forward_lemmas <> Q:187 var
R24081:24081 VST.floyd.forward_lemmas <> a:196 var
R24065:24065 VST.floyd.forward_lemmas <> P:186 var
R24067:24067 VST.floyd.forward_lemmas <> a:196 var
R24000:24003 VST.floyd.forward_lemmas <> incr:191 var
R23993:23995 VST.floyd.forward_lemmas <> PQR:183 var
R23997:23997 VST.floyd.forward_lemmas <> a:195 var
R23986:23990 VST.floyd.forward_lemmas <> Delta:185 var
R23980:23984 VST.floyd.forward_lemmas <> Espec:180 var
R23977:23978 VST.floyd.forward_lemmas <> cs:181 var
binder 23785:23785 <> a:197
R23789:23793 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R23911:23926 VST.veric.SeparationLogic <> loop1_ret_assert def
R23944:23947 VST.floyd.forward_lemmas <> Post:192 var
R23929:23931 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R23935:23936 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R23934:23934 VST.floyd.forward_lemmas <> A:182 var
binder 23932:23932 <> a:198
R23937:23939 VST.floyd.forward_lemmas <> PQR:183 var
R23941:23941 VST.floyd.forward_lemmas <> a:198 var
R23905:23908 VST.floyd.forward_lemmas <> body:190 var
R23811:23815 VST.floyd.canon <> PROPx def
R23860:23865 VST.floyd.canon <> LOCALx def
R23874:23877 VST.floyd.canon <> SEPx def
R23880:23880 VST.floyd.forward_lemmas <> R:188 var
R23882:23882 VST.floyd.forward_lemmas <> a:197 var
R23868:23868 VST.floyd.forward_lemmas <> Q:187 var
R23870:23870 VST.floyd.forward_lemmas <> a:197 var
R23848:23852 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R23856:23856 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R23818:23827 VST.veric.SeparationLogic <> typed_true def
R23844:23844 VST.floyd.forward_lemmas <> v:184 var
R23846:23846 VST.floyd.forward_lemmas <> a:197 var
R23830:23835 compcert.cfrontend.Clight <> typeof def
R23837:23840 VST.floyd.forward_lemmas <> test:189 var
R23853:23853 VST.floyd.forward_lemmas <> P:186 var
R23855:23855 VST.floyd.forward_lemmas <> a:197 var
R23804:23808 VST.floyd.forward_lemmas <> Delta:185 var
R23798:23802 VST.floyd.forward_lemmas <> Espec:180 var
R23795:23796 VST.floyd.forward_lemmas <> cs:181 var
binder 23670:23670 <> a:199
R23673:23679 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R23685:23686 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R23726:23730 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R23680:23684 VST.floyd.forward_lemmas <> Delta:185 var
R23687:23691 VST.floyd.canon <> PROPx def
R23700:23705 VST.floyd.canon <> LOCALx def
R23714:23717 VST.floyd.canon <> SEPx def
R23720:23720 VST.floyd.forward_lemmas <> R:188 var
R23722:23722 VST.floyd.forward_lemmas <> a:199 var
R23708:23708 VST.floyd.forward_lemmas <> Q:187 var
R23710:23710 VST.floyd.forward_lemmas <> a:199 var
R23694:23694 VST.floyd.forward_lemmas <> P:186 var
R23696:23696 VST.floyd.forward_lemmas <> a:199 var
R23731:23735 VST.veric.SeparationLogic <> local def
R23738:23739 VST.veric.lift LiftNotation :::'`('_x_')' not
R23748:23765 VST.veric.lift LiftNotation :::'`('_x_')' not
R23740:23741 Coq.Init.Logic <> eq ind
R23744:23744 VST.floyd.forward_lemmas <> v:184 var
R23746:23746 VST.floyd.forward_lemmas <> a:199 var
R23751:23759 VST.veric.expr <> eval_expr def
R23761:23764 VST.floyd.forward_lemmas <> test:189 var
binder 23545:23545 <> a:200
R23548:23554 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R23560:23561 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R23601:23606 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R23651:23651 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R23555:23559 VST.floyd.forward_lemmas <> Delta:185 var
R23562:23566 VST.floyd.canon <> PROPx def
R23575:23580 VST.floyd.canon <> LOCALx def
R23589:23592 VST.floyd.canon <> SEPx def
R23595:23595 VST.floyd.forward_lemmas <> R:188 var
R23597:23597 VST.floyd.forward_lemmas <> a:200 var
R23583:23583 VST.floyd.forward_lemmas <> Q:187 var
R23585:23585 VST.floyd.forward_lemmas <> a:200 var
R23569:23569 VST.floyd.forward_lemmas <> P:186 var
R23571:23571 VST.floyd.forward_lemmas <> a:200 var
R23607:23613 VST.veric.SeparationLogic <> tc_expr def
R23622:23626 compcert.cfrontend.Clight <> Eunop constr
R23646:23649 compcert.exportclight.Clightdefs <> tint def
R23641:23644 VST.floyd.forward_lemmas <> test:189 var
R23628:23639 compcert.cfrontend.Cop <> Onotbool constr
R23615:23619 VST.floyd.forward_lemmas <> Delta:185 var
R23521:23523 Coq.Init.Logic <> ::type_scope:x_'='_x not
R23498:23506 VST.veric.expr <> bool_type def
R23509:23514 compcert.cfrontend.Clight <> typeof def
R23516:23519 VST.floyd.forward_lemmas <> test:189 var
R23524:23527 Coq.Init.Datatypes <> true constr
R24488:24490 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R24494:24495 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
binder 24491:24491 <> a:201
R24500:24500 VST.floyd.forward_lemmas <> a:201 var
R24465:24474 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_loop prfax
R24488:24490 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R24494:24495 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
binder 24491:24491 <> a:202
R24500:24500 VST.floyd.forward_lemmas <> a:202 var
R24465:24474 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_loop prfax
R24514:24531 VST.floyd.base <> extract_exists_pre def
R24514:24531 VST.floyd.base <> extract_exists_pre def
R24572:24576 VST.floyd.canon <> PROPx def
R24619:24624 VST.floyd.canon <> LOCALx def
R24633:24636 VST.floyd.canon <> SEPx def
R24609:24612 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R24579:24588 VST.veric.SeparationLogic <> typed_true def
R24591:24596 compcert.cfrontend.Clight <> typeof def
R24550:24558 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_seq prfax
R24572:24576 VST.floyd.canon <> PROPx def
R24619:24624 VST.floyd.canon <> LOCALx def
R24633:24636 VST.floyd.canon <> SEPx def
R24609:24612 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R24579:24588 VST.veric.SeparationLogic <> typed_true def
R24591:24596 compcert.cfrontend.Clight <> typeof def
R24550:24558 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_seq prfax
R24731:24776 VST.msl.seplog <> ::logic:x_'&&'_x not
R24858:24858 VST.msl.seplog <> ::logic:x_'&&'_x not
R24671:24677 VST.veric.SeparationLogic <> tc_expr def
R24686:24690 compcert.cfrontend.Clight <> Eunop constr
R24707:24710 compcert.cfrontend.Ctypes <> Tint constr
R24723:24728 compcert.cfrontend.Ctypes <> noattr def
R24716:24721 compcert.cfrontend.Ctypes <> Signed constr
R24712:24714 compcert.cfrontend.Ctypes <> I32 constr
R24692:24699 compcert.cfrontend.Cop <> Onotbool constr
R24813:24817 VST.msl.seplog <> ::logic:x_'&&'_x not
R24857:24857 VST.msl.seplog <> ::logic:x_'&&'_x not
R24777:24781 VST.veric.SeparationLogic <> local def
R24784:24785 VST.veric.lift LiftNotation :::'`('_x_')' not
R24794:24811 VST.veric.lift LiftNotation :::'`('_x_')' not
R24786:24787 Coq.Init.Logic <> eq ind
R24797:24805 VST.veric.expr <> eval_expr def
R24818:24822 VST.floyd.canon <> PROPx def
R24831:24836 VST.floyd.canon <> LOCALx def
R24845:24848 VST.floyd.canon <> SEPx def
R24655:24663 VST.floyd.canon <> semax_pre thm
R24875:24890 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_ifthenelse prfax
R24731:24776 VST.msl.seplog <> ::logic:x_'&&'_x not
R24858:24858 VST.msl.seplog <> ::logic:x_'&&'_x not
R24671:24677 VST.veric.SeparationLogic <> tc_expr def
R24686:24690 compcert.cfrontend.Clight <> Eunop constr
R24707:24710 compcert.cfrontend.Ctypes <> Tint constr
R24723:24728 compcert.cfrontend.Ctypes <> noattr def
R24716:24721 compcert.cfrontend.Ctypes <> Signed constr
R24712:24714 compcert.cfrontend.Ctypes <> I32 constr
R24692:24699 compcert.cfrontend.Cop <> Onotbool constr
R24813:24817 VST.msl.seplog <> ::logic:x_'&&'_x not
R24857:24857 VST.msl.seplog <> ::logic:x_'&&'_x not
R24777:24781 VST.veric.SeparationLogic <> local def
R24784:24785 VST.veric.lift LiftNotation :::'`('_x_')' not
R24794:24811 VST.veric.lift LiftNotation :::'`('_x_')' not
R24786:24787 Coq.Init.Logic <> eq ind
R24797:24805 VST.veric.expr <> eval_expr def
R24818:24822 VST.floyd.canon <> PROPx def
R24831:24836 VST.floyd.canon <> LOCALx def
R24845:24848 VST.floyd.canon <> SEPx def
R24655:24663 VST.floyd.canon <> semax_pre thm
R24875:24890 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_ifthenelse prfax
R24907:24916 VST.msl.seplog <> andp_right meth
R24907:24916 VST.msl.seplog <> andp_right meth
R24932:24941 VST.msl.seplog <> andp_right meth
R24932:24941 VST.msl.seplog <> andp_right meth
R24957:24966 VST.msl.seplog <> andp_left2 meth
R24957:24966 VST.msl.seplog <> andp_left2 meth
R24982:24991 VST.floyd.canon <> sequential thm
R24982:24991 VST.floyd.canon <> sequential thm
R25002:25019 VST.floyd.canon <> semax_post_flipped thm
R25029:25038 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_skip prfax
R25002:25019 VST.floyd.canon <> semax_post_flipped thm
R25029:25038 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_skip prfax
R25060:25069 VST.msl.seplog <> andp_left2 meth
R25060:25069 VST.msl.seplog <> andp_left2 meth
R25126:25136 VST.floyd.canon <> insert_prop thm
R25126:25136 VST.floyd.canon <> insert_prop thm
R25126:25136 VST.floyd.canon <> insert_prop thm
R25148:25152 VST.floyd.canon <> PROPx def
R25161:25166 VST.floyd.canon <> LOCALx def
R25175:25178 VST.floyd.canon <> SEPx def
R25148:25152 VST.floyd.canon <> PROPx def
R25161:25166 VST.floyd.canon <> LOCALx def
R25175:25178 VST.floyd.canon <> SEPx def
R25238:25242 VST.veric.SeparationLogic <> local def
R25245:25249 VST.veric.mpred <> lift1 def
R25329:25338 VST.msl.seplog <> andp_left2 meth
R25329:25338 VST.msl.seplog <> andp_left2 meth
R25389:25398 VST.msl.seplog <> andp_left2 meth
R25389:25398 VST.msl.seplog <> andp_left2 meth
R25457:25466 VST.msl.seplog <> andp_left2 meth
R25457:25466 VST.msl.seplog <> andp_left2 meth
R25485:25493 VST.floyd.canon <> semax_pre thm
R25506:25516 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_break prfax
R25485:25493 VST.floyd.canon <> semax_pre thm
R25506:25516 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic semax_break prfax
R25558:25570 VST.msl.seplog <> derives_trans meth
R25558:25570 VST.msl.seplog <> derives_trans meth
R25606:25617 VST.msl.log_normalize <> andp_derives thm
R25606:25617 VST.msl.log_normalize <> andp_derives thm
R25638:25648 VST.floyd.canon <> insert_prop thm
R25638:25648 VST.floyd.canon <> insert_prop thm
R25638:25648 VST.floyd.canon <> insert_prop thm
R25668:25672 VST.floyd.canon <> PROPx def
R25681:25686 VST.floyd.canon <> LOCALx def
R25695:25698 VST.floyd.canon <> SEPx def
R25668:25672 VST.floyd.canon <> PROPx def
R25681:25686 VST.floyd.canon <> LOCALx def
R25695:25698 VST.floyd.canon <> SEPx def
R25758:25762 VST.veric.SeparationLogic <> local def
R25765:25769 VST.veric.mpred <> lift1 def
R25817:25834 VST.floyd.canon <> semax_post_flipped thm
R25817:25834 VST.floyd.canon <> semax_post_flipped thm
R25868:25877 VST.msl.seplog <> andp_left2 meth
R25868:25877 VST.msl.seplog <> andp_left2 meth
R25868:25877 VST.msl.seplog <> andp_left2 meth
R25868:25877 VST.msl.seplog <> andp_left2 meth
R25868:25877 VST.msl.seplog <> andp_left2 meth
R25925:25942 VST.floyd.canon <> semax_post_flipped thm
R25925:25942 VST.floyd.canon <> semax_post_flipped thm
R26012:26021 VST.msl.seplog <> andp_left2 meth
R26012:26021 VST.msl.seplog <> andp_left2 meth
R26012:26021 VST.msl.seplog <> andp_left2 meth
R26012:26021 VST.msl.seplog <> andp_left2 meth
R26012:26021 VST.msl.seplog <> andp_left2 meth
prf 26343:26355 <> semax_for_3g2
binder 26401:26405 <> Espec:203
R26412:26420 VST.veric.mpred <> compspecs class
binder 26408:26409 <> cs:204
binder 26424:26424 <> A:205
R26434:26437 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R26445:26448 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R26449:26453 VST.veric.mpred <> mpred def
R26438:26444 VST.veric.mpred <> environ ind
R26433:26433 VST.floyd.forward_lemmas <> A:205 var
binder 26428:26430 <> PQR:206
R26461:26464 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R26465:26467 compcert.common.Values <> val ind
R26460:26460 VST.floyd.forward_lemmas <> A:205 var
binder 26457:26457 <> v:207
binder 26470:26474 <> Delta:208
binder 26476:26476 <> P:209
binder 26478:26478 <> Q:210
binder 26480:26480 <> R:211
binder 26482:26485 <> test:212
binder 26487:26490 <> body:213
binder 26492:26495 <> incr:214
binder 26497:26500 <> Post:215
R26538:26546 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R26547:26547 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R26662:26671 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R26672:26672 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R26777:26786 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R26787:26787 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R26960:26969 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R26970:26970 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R27110:27119 Coq.Init.Logic <> ::type_scope:x_'->'_x not
R27121:27125 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R27290:27301 VST.veric.SeparationLogic <> overridePost def
R27430:27433 VST.floyd.forward_lemmas <> Post:215 var
R27326:27328 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R27332:27333 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R27331:27331 VST.floyd.forward_lemmas <> A:205 var
binder 27329:27329 <> a:216
R27334:27338 VST.floyd.canon <> PROPx def
R27384:27389 VST.floyd.canon <> LOCALx def
R27398:27401 VST.floyd.canon <> SEPx def
R27404:27404 VST.floyd.forward_lemmas <> R:211 var
R27406:27406 VST.floyd.forward_lemmas <> a:216 var
R27392:27392 VST.floyd.forward_lemmas <> Q:210 var
R27394:27394 VST.floyd.forward_lemmas <> a:216 var
R27372:27376 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R27380:27380 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R27341:27351 VST.veric.SeparationLogic <> typed_false def
R27368:27368 VST.floyd.forward_lemmas <> v:207 var
R27370:27370 VST.floyd.forward_lemmas <> a:216 var
R27354:27359 compcert.cfrontend.Clight <> typeof def
R27361:27364 VST.floyd.forward_lemmas <> test:212 var
R27377:27377 VST.floyd.forward_lemmas <> P:209 var
R27379:27379 VST.floyd.forward_lemmas <> a:216 var
R27210:27214 compcert.cfrontend.Clight <> Sloop constr
R27266:27269 VST.floyd.forward_lemmas <> incr:214 var
R27217:27225 compcert.cfrontend.Clight <> Ssequence constr
R27260:27263 VST.floyd.forward_lemmas <> body:213 var
R27228:27238 compcert.cfrontend.Clight <> Sifthenelse constr
R27251:27256 compcert.cfrontend.Clight <> Sbreak constr
R27245:27249 compcert.cfrontend.Clight <> Sskip constr
R27240:27243 VST.floyd.forward_lemmas <> test:212 var
R27143:27145 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R27149:27150 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R27148:27148 VST.floyd.forward_lemmas <> A:205 var
binder 27146:27146 <> a:217
R27151:27155 VST.floyd.canon <> PROPx def
R27164:27169 VST.floyd.canon <> LOCALx def
R27178:27181 VST.floyd.canon <> SEPx def
R27184:27184 VST.floyd.forward_lemmas <> R:211 var
R27186:27186 VST.floyd.forward_lemmas <> a:217 var
R27172:27172 VST.floyd.forward_lemmas <> Q:210 var
R27174:27174 VST.floyd.forward_lemmas <> a:217 var
R27158:27158 VST.floyd.forward_lemmas <> P:209 var
R27160:27160 VST.floyd.forward_lemmas <> a:217 var
R27136:27140 VST.floyd.forward_lemmas <> Delta:208 var
R27130:27134 VST.floyd.forward_lemmas <> Espec:203 var
R27127:27128 VST.floyd.forward_lemmas <> cs:204 var
binder 26978:26978 <> a:218
R26982:26986 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R27042:27058 VST.veric.SeparationLogic <> normal_ret_assert def
R27061:27063 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R27067:27068 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R27066:27066 VST.floyd.forward_lemmas <> A:205 var
binder 27064:27064 <> a:219
R27069:27073 VST.floyd.canon <> PROPx def
R27082:27087 VST.floyd.canon <> LOCALx def
R27096:27099 VST.floyd.canon <> SEPx def
R27102:27102 VST.floyd.forward_lemmas <> R:211 var
R27104:27104 VST.floyd.forward_lemmas <> a:219 var
R27090:27090 VST.floyd.forward_lemmas <> Q:210 var
R27092:27092 VST.floyd.forward_lemmas <> a:219 var
R27076:27076 VST.floyd.forward_lemmas <> P:209 var
R27078:27078 VST.floyd.forward_lemmas <> a:219 var
R27011:27014 VST.floyd.forward_lemmas <> incr:214 var
R27004:27006 VST.floyd.forward_lemmas <> PQR:206 var
R27008:27008 VST.floyd.forward_lemmas <> a:218 var
R26997:27001 VST.floyd.forward_lemmas <> Delta:208 var
R26991:26995 VST.floyd.forward_lemmas <> Espec:203 var
R26988:26989 VST.floyd.forward_lemmas <> cs:204 var
binder 26795:26795 <> a:220
R26799:26803 VST.floyd.SeparationLogicAsLogicSoundness MainTheorem.CSHL_PracticalLogic.CSHL_MinimumLogic.CSHL_Def semax defax
R26921:26937 VST.floyd.assert_lemmas <> loop1x_ret_assert def
R26955:26958 VST.floyd.forward_lemmas <> Post:215 var
R26940:26942 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R26946:26947 VST.msl.seplog <> ::logic:'EX'_x_'..'_x_','_x not
R26945:26945 VST.floyd.forward_lemmas <> A:205 var
binder 26943:26943 <> a:221
R26948:26950 VST.floyd.forward_lemmas <> PQR:206 var
R26952:26952 VST.floyd.forward_lemmas <> a:221 var
R26915:26918 VST.floyd.forward_lemmas <> body:213 var
R26821:26825 VST.floyd.canon <> PROPx def
R26870:26875 VST.floyd.canon <> LOCALx def
R26884:26887 VST.floyd.canon <> SEPx def
R26890:26890 VST.floyd.forward_lemmas <> R:211 var
R26892:26892 VST.floyd.forward_lemmas <> a:220 var
R26878:26878 VST.floyd.forward_lemmas <> Q:210 var
R26880:26880 VST.floyd.forward_lemmas <> a:220 var
R26858:26862 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R26866:26866 Coq.Init.Datatypes <> ::list_scope:x_'::'_x not
R26828:26837 VST.veric.SeparationLogic <> typed_true def
R26854:26854 VST.floyd.forward_lemmas <> v:207 var
R26856:26856 VST.floyd.forward_lemmas <> a:220 var
R26840:26845 compcert.cfrontend.Clight <> typeof def
R26847:26850 VST.floyd.forward_lemmas <> test:212 var
R26863:26863 VST.floyd.forward_lemmas <> P:209 var
R26865:26865 VST.floyd.forward_lemmas <> a:220 var
R26814:26818 VST.floyd.forward_lemmas <> Delta:208 var
R26808:26812 VST.floyd.forward_lemmas <> Espec:203 var
R26805:26806 VST.floyd.forward_lemmas <> cs:204 var
binder 26680:26680 <> a:222
R26683:26689 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R26695:26696 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R26736:26740 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R26690:26694 VST.floyd.forward_lemmas <> Delta:208 var
R26697:26701 VST.floyd.canon <> PROPx def
R26710:26715 VST.floyd.canon <> LOCALx def
R26724:26727 VST.floyd.canon <> SEPx def
R26730:26730 VST.floyd.forward_lemmas <> R:211 var
R26732:26732 VST.floyd.forward_lemmas <> a:222 var
R26718:26718 VST.floyd.forward_lemmas <> Q:210 var
R26720:26720 VST.floyd.forward_lemmas <> a:222 var
R26704:26704 VST.floyd.forward_lemmas <> P:209 var
R26706:26706 VST.floyd.forward_lemmas <> a:222 var
R26741:26745 VST.veric.SeparationLogic <> local def
R26748:26749 VST.veric.lift LiftNotation :::'`('_x_')' not
R26758:26775 VST.veric.lift LiftNotation :::'`('_x_')' not
R26750:26751 Coq.Init.Logic <> eq ind
R26754:26754 VST.floyd.forward_lemmas <> v:207 var
R26756:26756 VST.floyd.forward_lemmas <> a:222 var
R26761:26769 VST.veric.expr <> eval_expr def
R26771:26774 VST.floyd.forward_lemmas <> test:212 var
binder 26555:26555 <> a:223
R26558:26564 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R26570:26571 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R26611:26616 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R26661:26661 VST.floyd.canon <> :::'ENTAIL'_x_','_x_'|--'_x not
R26565:26569 VST.floyd.forward_lemmas <> Delta:208 var
R26572:26576 VST.floyd.canon <> PROPx def
R26585:26590 VST.floyd.canon <> LOCALx def
R26599:26602 VST.floyd.canon <> SEPx def
R26605:26605 VST.floyd.forward_lemmas <> R:211 var
R26607:26607 VST.floyd.forward_lemmas <> a:223 var
R26593:26593 VST.floyd.forward_lemmas <> Q:210 var
R26595:26595 VST.floyd.forward_lemmas <> a:223 var
R26579:26579 VST.floyd.forward_lemmas <> P:209 var
R26581:26581 VST.floyd.forward_lemmas <> a:223 var
R26617:26623 VST.veric.SeparationLogic <> tc_expr def
R26632:26636 compcert.cfrontend.Clight <> Eunop constr
R26656:26659 compcert.exportclight.Clightdefs <> tint def
R26651:26654 VST.floyd.forward_lemmas <> test:212 var
R26638:26649 compcert.cfrontend.Cop <> Onotbool constr
R26625:26629 VST.floyd.forward_lemmas <> Delta:208 var
R26531:26533 Coq.Init.Logic <> ::type_scope:x_'='_x not
R26508:26516 VST.veric.expr <> bool_type def
R26519:26524 compcert.cfrontend.Clight <> typeof def
R26526:26529 VST.floyd.forward_lemmas <> test:212 var
R26534:26537 Coq.Init.Datatypes <> true constr
R27459:27471 VST.floyd.forward_lemmas <> semax_for_3g1 thm
R27459:27471 VST.floyd.forward_lemmas <> semax_for_3g1 thm
R27511:27528 VST.floyd.canon <> semax_post_flipped thm
R27511:27528 VST.floyd.canon <> semax_post_flipped thm
R27594:27603 VST.msl.seplog <> andp_left2 meth
R27594:27603 VST.msl.seplog <> andp_left2 meth
R27594:27603 VST.msl.seplog <> andp_left2 meth
R27594:27603 VST.msl.seplog <> andp_left2 meth
R27594:27603 VST.msl.seplog <> andp_left2 meth
R27619:27625 VST.msl.log_normalize <> FF_left thm
R27619:27625 VST.msl.log_normalize <> FF_left thm
R27647:27656 VST.msl.seplog <> andp_left2 meth
R27647:27656 VST.msl.seplog <> andp_left2 meth
R27726:27732 VST.veric.expr <> tc_andp def
